# enabled by default:
#   -W#pragma-messages
#         %0
#   -Wabsolute-value
#         absolute value function %0 given an argument of type %1 but has parameter of type %2 which may cause truncation of value
#         taking the absolute value of %select{pointer|function|array}0 type %1 is suspicious
#         taking the absolute value of unsigned type %0 has no effect
#         using %select{integer|floating point|complex}1 absolute value function %0 when argument is of %select{integer|floating point|complex}2 type
#   -Wabstract-final-class
#         abstract class is marked '%select{final|sealed}0'
#   -Waddress
#     -Wpointer-bool-conversion
#           address of%select{| function| array}0 '%1' will always evaluate to 'true'
#           nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter
#     -Wstring-compare
#           result of comparison against %select{a string literal|@encode}0 is unspecified (use strncmp instead)
#     -Wtautological-pointer-compare
#           comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2
#           comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter
#   -Waddress-of-packed-member
#         taking address of packed member %0 of class or structure %q1 may result in an unaligned pointer value
#   -Waddress-of-temporary
#         taking the address of a temporary object of type %0
#   -Walloca-with-align-alignof
#         second argument to __builtin_alloca_with_align is supposed to be in bits
#   -Wambiguous-delete
#         multiple suitable %0 functions for %1; no 'operator delete' function will be invoked if initialization throws an exception
#   -Wambiguous-ellipsis
#         '...' in this location creates a C-style varargs function%select{, not a function parameter pack|}0
#   -Wambiguous-macro
#         ambiguous expansion of macro %0
#   -Wambiguous-member-template
#         lookup of %0 in member access expression is ambiguous; using member of %1
#   -Wanalyzer-incompatible-plugin
#         checker plugin '%0' is not compatible with this version of the analyzer
#   -Wanonymous-pack-parens
#         ISO C++11 requires a parenthesized pack declaration to have a name
#   -Warc
#     -Warc-non-pod-memaccess
#           %select{destination for|source of}0 this %1 call is a pointer to ownership-qualified type %2
#     -Warc-retain-cycles
#           capturing %0 strongly in this block is likely to lead to a retain cycle
#     -Warc-unsafe-retained-assign
#           assigning %select{array literal|dictionary literal|numeric literal|boxed expression|<should not happen>|block literal}0 to a weak %select{property|variable}1; object will be released after assignment
#           assigning retained object to %select{weak|unsafe_unretained}0 %select{property|variable}1; object will be released after assignment
#           assigning retained object to unsafe property; object will be released after assignment
#   -Warc-bridge-casts-disallowed-in-nonarc
#         '%0' casts have no effect when not using ARC
#   -Warc-performSelector-leaks
#         performSelector may cause a leak because its selector is unknown
#   -Wargument-outside-range
#         argument value %0 is outside the valid range [%1, %2]
#   -Warray-bounds
#         'static' has no effect on zero-length arrays
#         array argument is too small; contains %0 elements, callee requires at least %1
#         array index %0 is before the beginning of the array
#         array index %0 is past the end of the array (which contains %1 element%s2)
#   -Wasm
#     -Wasm-ignored-qualifier
#           ignored %0 qualifier on asm
#           meaningless 'volatile' on asm outside function
#     -Wasm-operand-widths
#           value size does not match register size specified by the constraint and modifier
#   -Wassume
#         the argument to %0 has side effects that will be discarded
#   -Wat-protocol
#         @protocol is using a forward protocol declaration of %0
#   -Watimport-in-framework-header
#         use of '@import' in framework header is discouraged, including this header requires -fmodules
#   -Watomic-alignment
#         misaligned or large atomic operation may incur significant performance penalty
#   -Watomic-memory-ordering
#         memory order argument to atomic operation is invalid
#   -Watomic-property-with-user-defined-accessor
#         writable atomic property %0 cannot pair a synthesized %select{getter|setter}1 with a user defined %select{getter|setter}2
#   -Wattribute-packed-for-bitfield
#         'packed' attribute was ignored on bit-fields with single-byte alignment in older versions of GCC and Clang
#   -Wattributes
#     -Wignored-attributes
#           %0 attribute argument not supported: %1
#           %0 attribute can only be applied to instance variables or properties
#           %0 attribute ignored
#           %0 attribute ignored for field of type %1
#           %0 attribute ignored on inline function
#           %0 attribute ignored when parsing type
#           %0 attribute is deprecated and ignored in OpenCL version %1
#           %0 attribute only applies to %1
#           %0 attribute only applies to %select{Objective-C object|pointer|pointer-to-CF-pointer}1 parameters
#           %0 attribute only applies to %select{functions|methods|properties}1 that return %select{an Objective-C object|a pointer|a non-retainable pointer}2
#           %0 attribute only applies to %select{functions|unions|variables and functions|functions and methods|functions, methods and blocks|functions, methods, and parameters|variables|variables and fields|variables, data members and tag types|types and namespaces|variables, functions and classes|kernel functions|non-K&R-style functions}1
#           %0 attribute only applies to a pointer or reference (%1 is invalid)
#           %0 attribute only applies to return values that are pointers
#           %0 attribute only applies to return values that are pointers or references
#           %0 attribute only applies to%select{| constant}1 pointer arguments
#           %0 calling convention ignored on constructor/destructor
#           %0 calling convention ignored on variadic function
#           %q0 redeclared inline; %1 attribute ignored
#           %select{alias|ifunc}1 will not be in section '%0' but in the same section as the %select{aliasee|resolver}2
#           %select{alias|ifunc}2 will always resolve to %0 even if weak definition of %1 is overridden
#           %select{alignment|size}0 of field %1 (%2 bits) does not match the %select{alignment|size}0 of the first field in transparent union; transparent_union attribute ignored
#           %select{unsupported|duplicate}0%select{| architecture}1 '%2' in the 'target' attribute string; 'target' attribute ignored
#           '%0' attribute cannot be specified on a definition
#           '%0' only applies to %select{function|pointer|Objective-C object or block pointer}1 types; type here is %2
#           'abi_tag' attribute on %select{non-inline|anonymous}0 namespace ignored
#           'deprecated' attribute on anonymous namespace ignored
#           'gnu_inline' attribute requires function to be marked 'inline', attribute ignored
#           'internal_linkage' attribute on a non-static local variable is ignored
#           'nocf_check' attribute ignored; use -fcf-protection to enable the attribute
#           'nonnull' attribute applied to function with no pointer arguments
#           'nonnull' attribute when used on parameters takes no arguments
#           'sentinel' attribute only supported for variadic %select{functions|blocks}0
#           'sentinel' attribute requires named arguments
#           'trivial_abi' cannot be applied to %0
#           MIPS 'interrupt' attribute only applies to functions that have %select{no parameters|a 'void' return type}0
#           Objective-C GC does not allow weak variables on the stack
#           RISC-V 'interrupt' attribute only applies to functions that have %select{no parameters|a 'void' return type}0
#           __declspec attribute %0 is not supported
#           __weak attribute cannot be specified on a field declaration
#           __weak attribute cannot be specified on an automatic variable when ARC is not enabled
#           attribute %0 after definition is ignored
#           attribute %0 cannot be applied to %select{functions|Objective-C method}1 without return value
#           attribute %0 ignored, because it cannot be applied to a type
#           attribute %0 ignored, because it cannot be applied to omitted return type
#           attribute %0 ignored, because it is not attached to a declaration
#           attribute %0 is already applied
#           attribute %0 is already applied with different parameters
#           attribute %0 is ignored, place it after "%select{class|struct|interface|union|enum}1" to apply attribute to type declaration
#           attribute declaration must precede definition
#           calling convention %0 ignored for this target
#           first field of a transparent union cannot have %select{floating point|vector}0 type %1; transparent_union attribute ignored
#           inheritance model ignored on %select{primary template|partial specialization}0
#           qualifiers after comma in declarator list are ignored
#           repeated RISC-V 'interrupt' attribute
#           transparent union definition must contain at least one field; transparent_union attribute ignored
#           transparent_union attribute can only be applied to a union definition; attribute ignored
#           unknown attribute '%0'
#           unknown visibility %0
#     -Wunknown-attributes
#           unknown attribute %0 ignored
#   -Wauto-disable-vptr-sanitizer
#         implicitly disabling vptr sanitizer because rtti wasn't enabled
#   -Wauto-storage-class
#         'auto' storage class specifier is not permitted in C++11, and will not be supported in future releases
#   -Wauto-var-id
#         'auto' deduced as 'id' in declaration of %0
#   -Wavailability
#         %select{|overriding }1method cannot be unavailable on %0 when %select{the protocol method it implements|its overridden method}1 is available
#         %select{|overriding }4method %select{introduced after|deprecated before|obsoleted before}0 %select{the protocol method it implements|overridden method}4 on %1 (%2 vs. %3)
#         'unavailable' availability overrides all other availability information
#         availability does not match previous declaration
#         feature cannot be %select{introduced|deprecated|obsoleted}0 in %1 version %2 before it was %select{introduced|deprecated|obsoleted}3 in version %4; attribute ignored
#         ignoring availability attribute %select{on '+load' method|with constructor attribute|with destructor attribute}0
#         unknown platform %0 in availability macro
#         use same version number separators '_' or '.'; as in 'major[.minor[.subminor]]'
#   -Wbackend-plugin
#         %0
#   -Wbackslash-newline-escape
#         backslash and newline separated by space
#   -Wbinding-in-condition
#         ISO C++17 does not permit structured binding declaration in a condition
#   -Wbitfield-width
#         width of anonymous bit-field (%0 bits) exceeds width of its type; value will be truncated to %1 bit%s1
#         width of bit-field %0 (%1 bits) exceeds the width of its type; value will be truncated to %2 bit%s2
#   -Wblock-capture-autoreleasing
#         block captures an autoreleasing out-parameter, which may result in use-after-free bugs
#   -Wbool-conversions
#     -Wbool-conversion
#           initialization of pointer of type %0 to null from a constant boolean expression
#       -Wpointer-bool-conversion
#             address of%select{| function| array}0 '%1' will always evaluate to 'true'
#             nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter
#       -Wundefined-bool-conversion
#             'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true
#             reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true
#   -Wbraced-scalar-init
#         braces around scalar initializer
#   -Wbridge-cast
#         %0 bridges to %1, not %2
#         %0 cannot bridge to %1
#   -Wbuiltin-macro-redefined
#         redefining builtin macro
#         undefining builtin macro
#   -Wbuiltin-memcpy-chk-size
#         %0 will always overflow destination buffer
#   -Wbuiltin-requires-header
#         declaration of built-in function '%1' requires inclusion of the header <%0>
#   -Wc++11-inline-namespace
#         inline namespaces are a C++11 feature
#   -Wc++1z-compat-mangling
#     -Wc++17-compat-mangling
#           mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature
#   -Wcast-calling-convention
#         cast between incompatible calling conventions '%0' and '%1'; calls through this pointer may abort at runtime
#   -Wcast-of-sel-type
#         cast of type %0 to %1 is deprecated; use sel_getName instead
#   -Wcast-qual-unrelated
#         ISO C++ does not allow %select{const_cast|static_cast|reinterpret_cast|dynamic_cast|C-style cast|functional-style cast}0 from %1 to %2 because it casts away qualifiers, even though the source and destination types are unrelated
#   -WCFString-literal
#         input conversion stopped due to an input byte that does not belong to the input codeset UTF-8
#   -Wclang-cl-pch
#         definition of macro %0 does not match definition in precompiled header
#         support for '%0' without a corresponding /FI flag not implemented yet; flag ignored
#         support for '%0' without a filename not implemented yet; flag ignored
#         support for '/Yc' and '/Yu' with different filenames not implemented yet; flags ignored
#         support for '/Yc' with more than one source file not implemented yet; flag ignored
#   -Wcompare-distinct-pointer-types
#         comparison of distinct pointer types%diff{ ($ and $)|}0,1
#   -Wconditional-type-mismatch
#         pointer/integer type mismatch in conditional expression%diff{ ($ and $)|}0,1
#   -Wconfig-macros
#         %select{definition|#undef}0 of configuration macro '%1' has no effect on the import of '%2'; pass '%select{-D%1=...|-U%1}0' on the command line to configure the module
#   -Wconstant-conversion
#         implicit conversion from %2 to %3 changes value from %0 to %1
#     -Wbitfield-constant-conversion
#           implicit truncation from %2 to bit-field changes value from %0 to %1
#   -Wconstant-logical-operand
#         use of logical '%0' with constant operand
#   -Wconstexpr-not-const
#         'constexpr' non-static member function will not be implicitly 'const' in C++14; add 'const' to avoid a change in behavior
#   -Wconversion-null
#     -Wnull-conversion
#           implicit conversion of %select{NULL|nullptr}0 constant to %1
#   -Wcoroutine
#     -Wcoroutine-missing-unhandled-exception
#           %0 is required to declare the member 'unhandled_exception()' when exceptions are enabled
#   -Wcpp
#     -W#warnings
#           %0
#   -Wdangling
#         %select{temporary %select{whose address is used as value of|%select{|implicitly }2bound to}4 %select{%select{|reference }4member of local variable|local %select{variable|reference}4}1|array backing %select{initializer list subobject of local variable|local initializer list}1}0 %select{%3 |}2will be destroyed at the end of the full-expression
#         sorry, lifetime extension of %select{temporary|backing array of initializer list}0 created by aggregate initialization using default member initializer is not supported; lifetime of %select{temporary|backing array}0 will end at the end of the full-expression
#     -Wdangling-field
#           %select{reference|backing array for 'std::initializer_list'}2 %select{|subobject of }1member %0 %select{binds to|is}2 a temporary object whose lifetime is shorter than the lifetime of the constructed object
#           binding reference member %0 to stack allocated %select{variable|parameter}2 %1
#           initializing pointer member %0 with the stack address of %select{variable|parameter}2 %1
#           temporary bound to reference member of allocated object will be destroyed at the end of the full-expression
#     -Wdangling-initializer-list
#           array backing %select{initializer list subobject of the allocated object|the allocated initializer list}0 will be destroyed at the end of the full-expression
#     -Wreturn-stack-address
#           %select{address of|reference to}0 stack memory associated with %select{local variable|parameter}2 %1 returned
#           returning %select{address of|reference to}0 local temporary object
#           returning address of label, which is local
#   -Wdealloc-in-category
#         -dealloc is being overridden in a category
#   -Wdebug-compression-unavailable
#         cannot compress debug sections (zlib not installed)
#   -Wdelegating-ctor-cycles
#         constructor for %0 creates a delegation cycle
#   -Wdelete-incomplete
#         cannot delete expression with pointer-to-'void' type %0
#         deleting pointer to incomplete type %0 may cause undefined behavior
#   -Wdeprecated-attributes
#         specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead
#   -Wdeprecated-declarations
#         %0 is deprecated
#         %0 is deprecated: %1
#         %0 may be deprecated because the receiver type is unknown
#         property access is using %0 method which is deprecated
#         specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead
#         use of C-style parameters in Objective-C method declarations is deprecated
#   -Wdeprecated-objc-isa-usage
#         assignment to Objective-C's isa is deprecated in favor of object_setClass()
#         direct access to Objective-C's isa is deprecated in favor of object_getClass()
#   -Wdeprecated-objc-pointer-introspection
#         bitmasking for introspection of Objective-C object pointers is strongly discouraged
#     -Wdeprecated-objc-pointer-introspection-performSelector
#           bitmasking for introspection of Objective-C object pointers is strongly discouraged
#   -Wdistributed-object-modifiers
#         conflicting distributed object modifiers on parameter type in implementation of %0
#         conflicting distributed object modifiers on return type in implementation of %0
#   -Wdiv-by-zero
#     -Wdivision-by-zero
#           %select{remainder|division}0 by zero is undefined
#   -Wdll-attribute-on-redeclaration
#         redeclaration of %q0 should not add %q1 attribute
#   -Wdllexport-explicit-instantiation-decl
#         explicit instantiation declaration should not be 'dllexport'
#   -Wdllimport-static-field-def
#         definition of dllimport static field
#   -Wduplicate-decl-specifier
#         duplicate '%0' declaration specifier
#         multiple identical address spaces specified for type
#   -Wduplicate-protocol
#         duplicate protocol definition of %0 is ignored
#   -Wempty-body
#         for loop has empty body
#         if statement has empty body
#         range-based for loop has empty body
#         switch statement has empty body
#         while loop has empty body
#   -Wempty-decomposition
#         ISO C++17 does not allow a decomposition group to be empty
#   -Wencode-type
#         encoding of %0 type is incomplete because %1 component has unknown encoding
#   -Wendif-labels
#     -Wextra-tokens
#           extra tokens at end of #%0 directive
#           extra tokens at the end of '#pragma omp %0' are ignored
#   -Wenum-compare
#         comparison of two values with different enumeration types%diff{ ($ and $)|}0,1
#     -Wenum-compare-switch
#           comparison of two values with different enumeration types in switch statement%diff{ ($ and $)|}0,1
#   -Wenum-conversion
#         implicit conversion from enumeration type %0 to different enumeration type %1
#   -Wenum-too-large
#         enumeration values exceed range of largest integer
#         incremented enumerator value %0 is not representable in the largest integer type
#   -Wexceptions
#         %0 has a non-throwing exception specification but can still throw
#         cannot refer to a non-static member from the handler of a %select{constructor|destructor}0 function try block
#         exception of type %0 will be caught by earlier handler
#   -Wexperimental-isel
#         -fexperimental-isel support for the '%0' architecture is incomplete
#         -fexperimental-isel support is incomplete for this architecture at the current optimization level
#   -Wexplicit-initialize-call
#         explicit call to +initialize results in duplicate call to +initialize
#         explicit call to [super initialize] should only be in implementation of +initialize
#   -Wextern-c-compat
#         %select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++
#   -Wextern-initializer
#         'extern' variable has an initializer
#   -Wextra-qualification
#         extra qualification on member %0
#   -Wfallback
#         falling back to %0
#   -Wflag-enum
#         enumeration value %0 is out of range of flags in enumeration type %1
#   -Wformat
#         %select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior
#         %select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead
#         '%0' is not a valid object format flag
#         '%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument
#         cannot mix positional and non-positional arguments in format string
#         data argument position '%0' exceeds the number of data arguments (%1)
#         field %select{width|precision}0 should have type %1, but argument has type %2
#         flag '%0' is ignored when flag '%1' is present
#         flag '%0' results in undefined behavior with '%1' conversion specifier
#         format specifies type %0 but the argument has %select{type|underlying type}2 %1
#         format string contains '\0' within the string body
#         format string is not null-terminated
#         format string missing
#         format string should not be a wide string
#         incomplete format specifier
#         invalid position specified for %select{field width|field precision}0
#         length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier
#         missing object format flag
#         more '%%' conversions than data arguments
#         no closing ']' for '%%[' in scanf format string
#         object format flags cannot be used with '%0' conversion specifier
#         position arguments in format strings start counting at 1 (not 0)
#         using '%%P' format specifier without precision
#         using '%0' format specifier annotation outside of os_log()/os_trace()
#         zero field width in scanf format string is unused
#     -Wformat-extra-args
#           data argument not used by format string
#     -Wformat-invalid-specifier
#           invalid conversion specifier '%0'
#     -Wformat-security
#           format string is not a string literal (potentially insecure)
#     -Wformat-y2k # DUMMY switch
#     -Wformat-zero-length
#           format string is empty
#     -Wnonnull
#           null passed to a callee that requires a non-null argument
#           null returned from %select{function|method}0 that requires a non-null return value
#   -Wframe-larger-than=
#         %0
#         stack frame size of %0 bytes in %q1
#   -Wframework-include-private-from-public
#         public framework header includes private framework header '%0'
#   -Wfunction-def-in-objc-container
#         function definition inside an Objective-C container is deprecated
#   -Wfunction-multiversion
#         CPU list contains duplicate entries; attribute ignored
#         body of cpu_dispatch function will be ignored
#   -Wgnu-alignof-expression
#         %0 applied to an expression is a GNU extension
#   -Wgnu-array-member-paren-init
#         parenthesized initialization of a member array is a GNU extension
#   -Wgnu-string-literal-operator-template
#         string literal operator templates are a GNU extension
#   -Wgnu-variable-sized-type-not-at-end
#         field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension
#   -Wheader-guard
#         %0 is used as a header guard here, followed by #define of a different macro
#   -Wignored-pragmas
#         #pragma %0(pop, ...) failed: %1
#         #pragma options align=reset failed: %0
#         '#pragma comment %0' ignored
#         '#pragma init_seg' is only supported when targeting a Microsoft environment
#         OpenCL extension end directive mismatches begin directive - ignoring
#         expected #pragma pack parameter to be '1', '2', '4', '8', or '16'
#         expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring
#         expected '#pragma unused' argument to be a variable name
#         expected ')' or ',' in '#pragma %0'
#         expected ',' in '#pragma %0'
#         expected '=' following '#pragma %select{align|options align}0' - ignored
#         expected 'align' following '#pragma options' - ignored
#         expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored
#         expected a stack label or a string literal for the section name in '#pragma %0' - ignored
#         expected a string literal for the section name in '#pragma %0' - ignored
#         expected action or ')' in '#pragma %0' - ignored
#         expected identifier in '#pragma %0' - ignored
#         expected integer between %0 and %1 inclusive in '#pragma %2' - ignored
#         expected integer or identifier in '#pragma pack' - ignored
#         expected non-wide string literal in '#pragma %0'
#         expected push, pop or a string literal for the section name in '#pragma %0' - ignored
#         expected string literal in '#pragma %0' - ignoring
#         extra tokens at end of '#pragma %0' - ignored
#         incorrect use of #pragma clang force_cuda_host_device begin|end
#         incorrect use of '#pragma ms_struct on|off' - ignored
#         invalid alignment option in '#pragma %select{align|options align}0' - ignored
#         known but unsupported action '%1' for '#pragma %0' - ignored
#         missing '(' after '#pragma %0' - ignoring
#         missing ')' after '#pragma %0' - ignoring
#         missing ':' after %0 - ignoring
#         missing ':' or ')' after %0 - ignoring
#         missing argument to '#pragma %0'%select{|; expected %2}1
#         missing argument to debug command '%0'
#         only variables can be arguments to '#pragma unused'
#         pragma pop_macro could not pop '%0', no matching push_macro
#         undeclared variable %0 used as an argument for '#pragma unused'
#         unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2
#         unexpected debug command '%0'
#         unknown OpenCL extension %0 - ignoring
#         unknown action '%1' for '#pragma %0' - ignored
#         unknown action for '#pragma %0' - ignored
#         unsupported OpenCL extension %0 - ignoring
#     -Wignored-pragma-intrinsic
#           %0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1
#     -Wignored-pragma-optimize
#           '#pragma optimize' is not supported
#   -Wimplicit-conversion-floating-point-to-bool
#         implicit conversion turns floating-point number into bool: %0 to %1
#   -Wimplicit-exception-spec-mismatch
#         function previously declared with an %select{explicit|implicit}0 exception specification redeclared with an %select{implicit|explicit}0 exception specification
#   -Wimplicit-int
#         type specifier missing, defaults to 'int'
#   -Wimplicitly-unsigned-literal
#         integer literal is too large to be represented in a signed integer type, interpreting as unsigned
#   -Winaccessible-base
#         direct base %0 is inaccessible due to ambiguity:%1
#   -Winclude-next-absolute-path
#         #include_next with absolute path
#   -Winclude-next-outside-header
#         #include_next in primary source file
#   -Wincompatible-exception-spec
#         exception specifications of %select{return|argument}0 types differ
#         target exception specification is not superset of source
#   -Wincompatible-library-redeclaration
#         incompatible redeclaration of library function %0
#   -Wincompatible-ms-struct
#         ms_struct may not produce Microsoft-compatible layouts for classes with base classes or virtual functions
#         ms_struct may not produce Microsoft-compatible layouts with fundamental data types with sizes that aren't a power of two
#   -Wincompatible-pointer-types
#         incompatible pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#     -Wincompatible-function-pointer-types
#           incompatible function pointer types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#     -Wincompatible-pointer-types-discards-qualifiers
#           %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers
#           %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 discards qualifiers in nested pointer types
#   -Wincompatible-property-type
#         property type %0 is incompatible with type %1 inherited from %2
#   -Wincompatible-sysroot
#         using sysroot for '%0' but targeting '%1'
#   -Wincomplete-framework-module-declaration
#         skipping '%0' because module declaration of '%1' lacks the 'framework' qualifier
#   -Wincomplete-implementation
#         method definition for %0 not found
#   -Wincomplete-umbrella
#         missing submodule '%0'
#         umbrella directory '%0' not found
#         umbrella header for module '%0' does not include header '%1'
#   -Winconsistent-dllimport
#         %q0 redeclared without %1 attribute: previous %1 ignored
#         %q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added
#   -Winconsistent-missing-override
#         %0 overrides a member function but is not marked 'override'
#   -Wincrement-bool
#         ISO C++17 does not allow incrementing expression of type bool
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#   -WIndependentClass-attribute
#         'objc_independent_class' attribute may be put on Objective-C object pointer type only; attribute is ignored
#         'objc_independent_class' attribute may be put on a typedef only; attribute is ignored
#   -Winitializer-overrides
#         initializer overrides prior initialization of this subobject
#         subobject initialization overrides initialization of other fields within its enclosing subobject
#   -Winjected-class-name
#         ISO C++ specifies that qualified reference to %0 is a constructor name rather than a %select{template name|type}1 in this context, despite preceding %select{'typename'|'template'}2 keyword
#   -Winline-asm
#         %0
#   -Winline-new-delete
#         replacement function %0 cannot be declared 'inline'
#   -Winstantiation-after-specialization
#         explicit instantiation of %0 that occurs after an explicit specialization has no effect
#   -Wint-conversions
#     -Wint-conversion
#           incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#           incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#   -Wint-to-pointer-cast
#         cast to %1 from smaller integer type %0
#     -Wint-to-void-pointer-cast
#           cast to %1 from smaller integer type %0
#   -Winteger-overflow
#         overflow in expression; result is %0 with type %1
#   -Winvalid-command-line-argument
#         optimization level '%0' is not supported; using '%1%2' instead
#         the object size sanitizer has no effect at -O0, but is explicitly enabled: %0
#     -Wignored-optimization-argument
#           optimization flag '%0' is not supported
#           optimization flag '%0' is not supported for target '%1'
#   -Winvalid-constexpr
#         constexpr %select{function|constructor}0 never produces a constant expression
#   -Winvalid-iboutlet
#         %select{instance variable|property}2 with %0 attribute must be an object type (invalid %1)
#         IBOutletCollection properties should be copy/strong and not assign
#   -Winvalid-initializer-from-system-header
#         invalid constructor form class in system header, should not be explicit
#   -Winvalid-ios-deployment-target
#         invalid iOS deployment version '%0', iOS 10 is the maximum deployment target for 32-bit targets
#   -Winvalid-noreturn
#         function %0 declared 'noreturn' should not return
#         function declared 'noreturn' should not return
#   -Winvalid-offsetof
#         offset of on non-POD type %0
#         offset of on non-standard-layout type %0
#   -Winvalid-partial-specialization
#         %select{class|variable}0 template partial specialization is not more specialized than the primary template
#   -Winvalid-pp-token
#         empty character constant
#         missing terminating %select{'|'"'}0 character
#   -Winvalid-source-encoding
#         illegal character encoding in character literal
#         illegal character encoding in string literal
#   -Winvalid-token-paste
#         pasting formed '%0', an invalid preprocessing token
#   -Wjump-seh-finally
#         jump out of __finally block has undefined behavior
#   -Wkeyword-compat
#         keyword '%0' will be made available as an identifier %select{here|for the remainder of the translation unit}1
#   -Wknr-promoted-parameter
#         %diff{promoted type $ of K&R function parameter is not compatible with the parameter type $|promoted type of K&R function parameter is not compatible with parameter type}0,1 declared in a previous prototype
#   -Wlarge-by-value-copy
#         %0 is a large (%1 bytes) pass-by-value argument; pass it by reference instead ?
#         return value of %0 is a large (%1 bytes) pass-by-value object; pass it by reference instead ?
#   -Wliteral-conversion
#         implicit conversion from %0 to %1 changes value from %2 to %3
#         implicit conversion of out of range value from %0 to %1 is undefined
#   -Wliteral-range
#         magnitude of floating-point constant too large for type %0; maximum is %1
#         magnitude of floating-point constant too small for type %0; minimum is %1
#   -Wmacro-redefined
#         %0 macro redefined
#   -Wmain-return-type
#         return type of 'main' is not 'int'
#   -Wmalformed-warning-check
#         __has_warning expected option name (e.g. "-Wundef")
#   -Wmany-braces-around-scalar-init
#         too many braces around scalar initializer
#   -Wmax-unsigned-zero
#         taking the max of %select{a value and unsigned zero|unsigned zero and a value}0 is always equal to the other value
#   -Wmemsize-comparison
#         size argument in %0 call is a comparison
#   -Wmicrosoft-cast
#         implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension
#         static_cast between pointer-to-function and pointer-to-object is a Microsoft extension
#   -Wmicrosoft-const-init
#         default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension
#   -Wmicrosoft-default-arg-redefinition
#         redefinition of default argument
#   -Wmicrosoft-enum-forward-reference
#         forward references to 'enum' types are a Microsoft extension
#   -Wmicrosoft-exists
#         dependent %select{__if_not_exists|__if_exists}0 declarations are ignored
#   -Wmicrosoft-explicit-constructor-call
#         explicit constructor calls are a Microsoft extension
#   -Wmicrosoft-extra-qualification
#         extra qualification on member %0
#   -Wmicrosoft-goto
#         jump from this goto statement to its label is a Microsoft extension
#   -Wmicrosoft-inaccessible-base
#         accessing inaccessible direct base %0 of %1 is a Microsoft extension
#   -Wmicrosoft-mutable-reference
#         'mutable' on a reference type is a Microsoft extension
#   -Wmicrosoft-pure-definition
#         function definition with pure-specifier is a Microsoft extension
#   -Wmicrosoft-sealed
#         'sealed' keyword is a Microsoft extension
#   -Wmicrosoft-template
#         %select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension
#         duplicate explicit instantiation of %0 ignored as a Microsoft extension
#         non-type template argument containing a dereference operation is a Microsoft extension
#         template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension
#         use of identifier %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#         use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension
#         using the undeclared type %0 as a default template argument is a Microsoft extension
#   -Wmicrosoft-union-member-reference
#         union member %0 has reference type %1, which is a Microsoft extension
#   -Wmicrosoft-unqualified-friend
#         unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier
#   -Wmicrosoft-using-decl
#         using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension
#   -Wmicrosoft-void-pseudo-dtor
#         pseudo-destructors on type void are a Microsoft extension
#   -Wmismatched-new-delete
#         'delete%select{|[]}0' applied to a pointer that was allocated with 'new%select{[]|}0'; did you mean 'delete%select{[]|}0'?
#   -Wmismatched-parameter-types
#         conflicting parameter types in implementation of %0%diff{: $ vs $|}1,2
#   -Wmismatched-return-types
#         conflicting return type in implementation of %0%diff{: $ vs $|}1,2
#   -Wmissing-declarations
#         '%0' ignored on this declaration
#         '%0' is not permitted on a declaration of a type
#         declaration does not declare anything
#         typedef requires a name
#   -Wmissing-exception-spec
#         %0 is missing exception specification '%1'
#   -Wmissing-noescape
#         parameter of overriding method should be annotated with __attribute__((noescape))
#   -Wmissing-prototype-for-cc
#         function with no prototype cannot use the %0 calling convention
#   -Wmissing-selector-name
#         %0 used as the name of the previous parameter rather than as part of the selector
#   -Wmissing-sysroot
#         no such sysroot directory: '%0'
#   -Wmodule-conflict
#         module '%0' conflicts with already-imported module '%1': %2
#         module file '%0' was validated as a system module and is now being imported as a non-system module; any difference in diagnostic options will be ignored
#   -Wmodule-file-config-mismatch
#         module file %0 cannot be loaded due to a configuration mismatch with the current compilation
#   -Wmodule-file-extension
#         duplicate module file extension block name '%0'
#   -Wmodule-import-in-extern-c
#         import of C++ module '%0' appears within extern "C" language linkage specification
#   -Wmodules-ambiguous-internal-linkage
#         ambiguous use of internal linkage declaration %0 defined in multiple modules
#   -Wmodules-import-nested-redundant
#         redundant #include of module '%0' appears within %1
#   -Wmsvc-include
#     -Wmicrosoft-include
#           #include resolved using non-portable Microsoft search rules as: %0
#   -Wmsvc-not-found
#         unable to find a Visual Studio installation; try running Clang from a developer command prompt
#   -Wmultichar
#         multi-character character constant
#   -Wmultiple-move-vbase
#         defaulted move assignment operator of %0 will move assign virtual base class %1 multiple times
#   -Wnew-returns-null
#         %0 should not return a null pointer unless it is declared 'throw()'%select{| or 'noexcept'}1
#   -Wnoexcept-type
#     -Wc++17-compat-mangling
#           mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature
#   -Wnon-literal-null-conversion
#         expression which evaluates to zero treated as a null pointer constant of type %0
#   -Wnon-pod-varargs
#         cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3
#         cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime
#         second argument to 'va_arg' is of ARC ownership-qualified type %0
#         second argument to 'va_arg' is of non-POD type %0
#   -Wnonportable-include-path
#         non-portable path to file '%0'; specified path differs in case from file name on disk
#   -Wnonportable-vector-initialization
#         vector initializers are not compatible with NEON intrinsics in big endian mode
#   -Wnsconsumed-mismatch
#         overriding method has mismatched ns_consumed attribute on its parameter
#   -WNSObject-attribute
#         'NSObject' attribute may be put on a typedef only; attribute is ignored
#   -Wnsreturns-mismatch
#         overriding method has mismatched ns_returns_%select{not_retained|retained}0 attributes
#   -Wnull-arithmetic
#         comparison between NULL and non-pointer %select{(%1 and NULL)|(NULL and %1)}0
#         use of NULL in arithmetic operation
#   -Wnull-character
#         null character ignored
#         null character(s) preserved in %select{char|string}0 literal
#   -Wnull-dereference
#         binding dereferenced null pointer to reference has undefined behavior
#         indirection of non-volatile null pointer will be deleted, not trap
#   -Wnullability
#         conflicting nullability specifier on parameter types, %0 conflicts with existing specifier %1
#         conflicting nullability specifier on return types, %0 conflicts with existing specifier %1
#         duplicate nullability specifier %0
#         nullability specifier %0 conflicts with existing specifier %1
#         synthesized setter %0 for null_resettable property %1 does not handle nil
#   -Wnullability-completeness
#         %select{pointer|block pointer|member pointer}0 is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)
#     -Wnullability-completeness-on-arrays
#           array parameter is missing a nullability type specifier (_Nonnull, _Nullable, or _Null_unspecified)
#   -Wnullability-declspec
#         nullability specifier %0 cannot be applied to non-pointer type %1; did you mean to apply the specifier to the %select{pointer|block pointer|member pointer|function pointer|member function pointer}2?
#   -Wnullability-inferred-on-nested-type
#         inferring '_Nonnull' for pointer type within %select{array|reference}0 is deprecated
#   -Wobjc-autosynthesis-property-ivar-name-match
#         autosynthesized property %0 will use %select{|synthesized}1 instance variable %2, not existing instance variable %3
#   -Wobjc-circular-container
#         adding %0 to %1 might cause circular dependency in container
#   -Wobjc-cocoa-api
#     -Wobjc-redundant-api-use
#       -Wobjc-redundant-literal-use
#             using %0 with a literal is redundant
#   -Wobjc-designated-initializers
#         convenience initializer missing a 'self' call to another initializer
#         convenience initializer should not invoke an initializer on 'super'
#         designated initializer invoked a non-designated initializer
#         designated initializer missing a 'super' call to a designated initializer of the super class
#         designated initializer should only invoke a designated initializer on 'super'
#         method override for the designated initializer of the superclass %objcinstance0 not found
#   -Wobjc-flexible-array
#         field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3
#         field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables
#   -Wobjc-forward-class-redefinition
#         redefinition of forward class %0 of a typedef name of an object type is ignored
#   -Wobjc-literal-compare
#         direct comparison of %select{an array literal|a dictionary literal|a numeric literal|a boxed expression|}0 has undefined behavior
#     -Wobjc-string-compare
#           direct comparison of a string literal has undefined behavior
#   -Wobjc-literal-conversion
#         implicit boolean conversion of Objective-C object literal always evaluates to true
#         object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2
#   -Wobjc-macro-redefinition
#         ignoring redefinition of Objective-C qualifier macro
#   -Wobjc-method-access
#         class method %objcclass0 not found (return type defaults to 'id')
#         class method %objcclass0 not found (return type defaults to 'id'); did you mean %objcclass2?
#         instance method %0 found instead of class method %1
#         instance method %0 is being used on 'Class' which is not in the root class
#         instance method %objcinstance0 not found (return type defaults to 'id')
#         instance method %objcinstance0 not found (return type defaults to 'id'); did you mean %objcinstance2?
#   -Wobjc-missing-super-calls
#         method possibly missing a [super %0] call
#   -Wobjc-multiple-method-names
#         multiple methods named %0 found
#   -Wobjc-noncopy-retain-block-property
#         retain'ed block property does not copy the block - use copy attribute instead
#   -Wobjc-nonunified-exceptions
#         cannot catch an exception thrown with @throw in C++ in the non-unified exception model
#   -Wobjc-property-implementation
#         class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category
#         class property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this class implementation
#         property %0 requires method %1 to be defined - use @dynamic or provide a method implementation in this category
#         property %0 requires method %1 to be defined - use @synthesize, @dynamic or provide a method implementation in this class implementation
#   -Wobjc-property-implicit-mismatch
#         primary property declaration is implicitly strong while redeclaration in class extension is weak
#   -Wobjc-property-matches-cocoa-ownership-rule
#         property follows Cocoa naming convention for returning 'owned' objects
#   -Wobjc-property-no-attribute
#         default property attribute 'assign' not appropriate for object
#         no 'assign', 'retain', or 'copy' attribute is specified - 'assign' is assumed
#   -Wobjc-property-synthesis
#         auto property synthesis will not synthesize property %0 because it cannot share an ivar with another synthesized property
#         auto property synthesis will not synthesize property %0 because it is 'readwrite' but it will be synthesized 'readonly' via another property
#         auto property synthesis will not synthesize property %0; it will be implemented by its superclass, use @dynamic to acknowledge intention
#   -Wobjc-protocol-method-implementation
#         category is implementing a method which will also be implemented by its primary class
#   -Wobjc-protocol-property-synthesis
#         auto property synthesis will not synthesize property %0 declared in protocol %1
#   -Wobjc-protocol-qualifiers
#         parameterized class %0 already conforms to the protocols listed; did you forget a '*'?
#   -Wobjc-readonly-with-setter-property
#         setter cannot be specified for a readonly property
#   -Wobjc-root-class
#         class %0 defined without specifying a base class
#   -Wobjc-string-concatenation
#         concatenated NSString literal for an NSArray expression - possibly missing a comma
#   -Wobjc-unsafe-perform-selector
#         %0 is incompatible with selectors that return a %select{struct|union|vector}1 type
#   -Wodr
#         type %0 has incompatible definitions in different translation units
#   -Wopencl-unsupported-rgba
#         vector component name '%0' is an OpenCL version 2.2 feature
#   -Wopenmp-clauses
#         aligned clause will be ignored because the requested alignment is not a power of 2
#         zero linear step (%0 %select{|and other variables in clause }1should probably be const)
#   -Wopenmp-loop-form
#         OpenMP loop iteration variable cannot have more than 64 bits size and will be narrowed
#         initialization clause of OpenMP for loop is not in canonical form ('var = init' or 'T var = init')
#   -Wopenmp-target
#         No library '%0' found in the default clang lib directory or in LIBRARY_PATH. Expect degraded performance due to no inlining of runtime functions on target devices.
#         Non-trivial type %0 is mapped, only trivial types are guaranteed to be mapped correctly
#         The OpenMP offloading target '%0' is similar to target '%1' already specified - will be ignored.
#         declaration is not declared in any declare target region
#   -Woption-ignored
#         The '%0' architecture does not support -moutline; flag ignored
#         auto-vectorization requires HVX, use -mhvx to enable it
#         ignoring '%0' option as it cannot be used with %select{implicit usage of|}1 -mabicalls and the N64 ABI
#         ignoring '-mlong-calls' option as it is not currently supported with %select{|the implicit usage of }0-mabicalls
#         option '%0' was ignored by the PS4 toolchain, using '-fPIC'
#         option '-ffine-grained-bitfield-accesses' cannot be enabled together with a sanitizer; flag ignored
#   -Wordered-compare-function-pointers
#         ordered comparison of function pointers (%0 and %1)
#   -Wout-of-line-declaration
#         out-of-line declaration of a member must be a definition
#   -Wout-of-scope-function
#         use of out-of-scope declaration of %0%select{| whose type is not compatible with that of an implicit declaration}1
#   -Woverride-module
#         overriding the module target triple with %0
#   -Woverriding-t-option
#         overriding '%0' option with '%1'
#   -Wparentheses
#         %0 has lower precedence than %1; %1 will be evaluated first
#         operator '?:' has lower precedence than '%0'; '%0' will be evaluated first
#         using the result of an assignment as a condition without parentheses
#     -Wbitwise-op-parentheses
#           '%0' within '%1'
#     -Wdangling-else
#           add explicit braces to avoid dangling else
#     -Wlogical-not-parentheses
#           logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0
#     -Wlogical-op-parentheses
#           '&&' within '||'
#     -Woverloaded-shift-op-parentheses
#           overloaded operator %select{>>|<<}0 has higher precedence than comparison operator
#     -Wparentheses-equality
#           equality comparison with extraneous parentheses
#     -Wshift-op-parentheses
#           operator '%0' has lower precedence than '%1'; '%1' will be evaluated first
#   -Wpass-failed
#         %0
#   -Wpch-date-time
#         %select{precompiled header|module}0 uses __DATE__ or __TIME__
#   -Wpointer-sign
#         %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2 converts between pointers to integer types with different sign
#   -Wpointer-type-mismatch
#         pointer type mismatch%diff{ ($ and $)|}0,1
#   -Wpragma-clang-attribute
#         unused attribute %0 in '#pragma clang attribute push' region
#   -Wpragma-once-outside-header
#         #pragma once in main file
#   -Wpragma-system-header-outside-header
#         #pragma system_header ignored in main file
#   -Wpredefined-identifier-outside-function
#         predefined identifier is only valid inside function
#   -Wprivate-extern
#         use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#   -Wprivate-header
#         use of private header from outside its module: '%0'
#   -Wprivate-module
#         expected canonical name for private module '%0'
#         module '%0' already re-exported as '%1'
#         no submodule named %0 in module '%1'; using top level '%2'
#         private submodule '%0' in private module map, expected top-level module
#   -Wprofile-instr-out-of-date
#         profile data may be out of date: of %0 function%s0, %1 %plural{1:has|:have}1 mismatched data that will be ignored
#   -Wprofile-instr-unprofiled
#         no profile data available for file "%0"
#   -Wproperty-access-dot-syntax
#         property %0 not found on object of type %1; did you mean to access property %2?
#   -Wproperty-attribute-mismatch
#         '%1' attribute on property %0 does not match the property inherited from %2
#         attribute 'readonly' of property %0 restricts attribute 'readwrite' of property inherited from %1
#         getter name mismatch between property redeclaration (%1) and its original declaration (%0)
#         property attribute in class extension does not match the primary class
#   -Wprotocol
#         method %0 in protocol %1 not implemented
#   -Wprotocol-property-synthesis-ambiguity
#         property %select{of type %1|with attribute '%1'|without attribute '%1'|with getter %1|with setter %1}0 was selected for synthesis
#   -Wqualified-void-return-type
#         function cannot return qualified void type %0
#   -Wreadonly-iboutlet-property
#         readonly IBOutlet property %0 when auto-synthesized may not work correctly with 'nib' loader
#   -Wreceiver-expr
#         receiver type %0 is not 'id' or interface pointer, consider casting it to 'id'
#   -Wredeclared-class-member
#         class member cannot be redeclared
#   -Wregister
#         ISO C++17 does not allow 'register' storage class specifier
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#   -Wreinterpret-base-class
#         'reinterpret_cast' %select{from|to}3 class %0 %select{to|from}3 its %select{virtual base|base at non-zero offset}2 %1 behaves differently from 'static_cast'
#   -Wrequires-super-attribute
#         %0 attribute cannot be applied to %select{methods in protocols|dealloc}1
#   -Wreturn-type
#         %select{void function|void method|constructor|destructor}1 %0 should not return a value
#         control may reach end of coroutine; which is undefined behavior because the promise type %0 does not declare 'return_void()'
#         control may reach end of non-void function
#         control may reach end of non-void lambda
#         control reaches end of coroutine; which is undefined behavior because the promise type %0 does not declare 'return_void()'
#         control reaches end of non-void function
#         control reaches end of non-void lambda
#         non-void %select{function|method}1 %0 should return a value
#     -Wreturn-type-c-linkage
#           %0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C
#           %0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C
#   -Wsection
#         %select{codeseg|section}0 does not match previous declaration
#         duplicate code segment specifiers
#         section attribute is specified on redeclared variable
#   -Wself-assign-field
#         assigning %select{field|instance variable}0 to itself
#   -Wsentinel
#         missing sentinel in %select{function call|method dispatch|block call}0
#         not enough variable arguments in %0 declaration to fit a sentinel
#   -Wsequence-point
#     -Wunsequenced
#           multiple unsequenced modifications to %0
#           unsequenced modification and access to %0
#   -Wserialized-diagnostics
#         unable to merge a subprocess's serialized diagnostics
#         unable to open file %0 for serializing diagnostics (%1)
#   -Wshadow-ivar
#         local declaration of %0 hides instance variable
#   -Wshift-count-negative
#         shift count is negative
#   -Wshift-count-overflow
#         shift count >= width of type
#   -Wshift-negative-value
#         shifting a negative signed value is undefined
#   -Wshift-overflow
#         signed shift result (%0) requires %1 bits to represent, but %2 only has %3 bits
#   -Wsizeof-array-argument
#         sizeof on array function parameter will return size of %0 instead of %1
#   -Wsizeof-array-decay
#         sizeof on pointer operation will return size of %0 instead of %1
#   -Wslash-u-filename
#         '/U%0' treated as the '/U' option
#   -Wstatic-float-init
#         in-class initializer for static data member of type %0 requires 'constexpr' specifier
#     -Wgnu-static-float-init
#           in-class initializer for static data member of type %0 is a GNU extension
#   -Wstatic-inline-explicit-instantiation
#         ignoring '%select{static|inline}0' keyword on explicit template instantiation
#   -Wstatic-local-in-inline
#         non-constant static local variable in inline function may be different in different files
#   -Wstatic-self-init
#         static variable %0 is suspiciously used within its own initialization
#   -Wstdlibcxx-not-found
#         include path for stdlibc++ headers not found; pass '-stdlib=libc++' on the command line to use the libc++ standard library instead
#   -Wstring-plus-char
#         adding %0 to a string pointer does not append to the string
#   -Wstring-plus-int
#         adding %0 to a string does not append to the string
#   -Wstrlcpy-strlcat-size
#         size argument in %0 call appears to be size of the source; expected the size of the destination
#   -Wstrncat-size
#         size argument in 'strncat' call appears to be size of the source
#         the value of the size argument in 'strncat' is too large, might lead to a buffer overflow
#         the value of the size argument to 'strncat' is wrong
#   -Wsuspicious-memaccess
#     -Wdynamic-class-memaccess
#           %select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to %select{|class containing a }2dynamic class %3; vtable pointer will be %select{overwritten|copied|moved|compared}4
#     -Wmemset-transposed-args
#           %select{'size' argument to memset is '0'|setting buffer to a 'sizeof' expression}0; did you mean to transpose the last two arguments?
#     -Wnontrivial-memaccess
#           %select{destination for|source of|first operand of|second operand of}0 this %1 call is a pointer to record %2 that is not trivial to %select{primitive-default-initialize|primitive-copy}3
#     -Wsizeof-pointer-memaccess
#           '%0' call operates on objects of type %1 while the size is based on a different type %2
#           argument to 'sizeof' in %0 call is the same pointer type %1 as the %select{destination|source}2; expected %3 or an explicit length
#     -Wsuspicious-bzero
#           'size' argument to bzero is '0'
#   -Wswitch
#         %plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0
#         case value not in enumerated type %0
#         overflow converting case value to switch condition type (%0 to %1)
#   -Wswitch-bool
#         switch condition has boolean value
#   -Wsync-fetch-and-nand-semantics-changed
#         the semantics of this intrinsic changed with GCC version 4.4 - the newer semantics are provided here
#   -Wtautological-constant-compare
#         result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
#     -Wtautological-constant-out-of-range-compare
#           result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
#   -Wtautological-undefined-compare
#         'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
#         reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
#   -Wtentative-definition-incomplete-type
#         tentative definition of variable with internal linkage has incomplete non-array type %0
#   -Wtrigraphs
#         ignored trigraph would end block comment
#         trigraph converted to '%0' character
#         trigraph ends block comment
#         trigraph ignored
#   -Wtype-safety
#         argument type %0 doesn't match specified %1 type tag %select{that requires %3|}2
#         specified %0 type tag requires a null pointer
#         this type tag was not designed to be used with this function
#   -Wtypedef-redefinition
#         redefinition of typedef %0 is a C11 feature
#   -Wtypename-missing
#         missing 'typename' prior to dependent type name '%0%1'
#   -Wunable-to-open-stats-file
#         unable to open statistics output file '%0': '%1'
#   -Wunavailable-declarations
#         %0 may be unavailable because the receiver type is unknown
#   -Wundefined-inline
#         inline function %q0 is not defined
#   -Wundefined-internal
#         %select{function|variable}0 %q1 has internal linkage but is not defined
#   -Wundefined-var-template
#         instantiation of variable %q0 required here, but no definition is available
#   -Wunguarded-availability-new
#         %0 is only available on %1 %2 or newer
#   -Wunicode
#         \%0 used with no following hex digits; treating as '\' followed by identifier
#         incomplete universal character name; treating as '\' followed by identifier
#         universal character name refers to a surrogate character
#         universal character names are only valid in C99 or C++
#         universal character names are only valid in C99 or C++; treating as '\' followed by identifier
#   -Wunicode-homoglyph
#         treating Unicode character <U+%0> as identifier character rather than as '%1' symbol
#   -Wunicode-whitespace
#         treating Unicode character as whitespace
#   -Wunknown-argument
#         unknown argument ignored in clang-cl '%0' (did you mean '%1'?)
#         unknown argument ignored in clang-cl: '%0'
#   -Wunknown-escape-sequence
#         unknown escape sequence '\%0'
#   -Wunknown-sanitizers
#         unknown sanitizer '%0' ignored
#   -Wunknown-warning-option
#         unknown %0 warning specifier: '%1'
#         unknown %select{warning|remark}0 option '%1'%select{|; did you mean '%3'?}2
#         unknown warning group '%0', ignored
#   -Wunsupported-abs
#         ignoring '-mabs=2008' option because the '%0' architecture does not support it
#         ignoring '-mabs=legacy' option because the '%0' architecture does not support it
#   -Wunsupported-availability-guard
#         %select{@available|__builtin_available}0 does not guard availability here; use if (%select{@available|__builtin_available}0) instead
#   -Wunsupported-cb
#         ignoring '-mcompact-branches=' option because the '%0' architecture does not support it
#   -Wunsupported-friend
#         dependent nested name specifier '%0' for friend class declaration is not supported; turning off access control for %1
#         dependent nested name specifier '%0' for friend template declaration is not supported; ignoring this friend declaration
#   -Wunsupported-gpopt
#         ignoring '-mgpopt' option as it cannot be used with %select{|the implicit usage of }0-mabicalls
#   -Wunsupported-nan
#         ignoring '-mnan=2008' option because the '%0' architecture does not support it
#         ignoring '-mnan=legacy' option because the '%0' architecture does not support it
#   -Wunsupported-target-opt
#         debug information option '%0' is not supported for target '%1'
#   -Wunsupported-visibility
#         target does not support 'protected' visibility; using 'default'
#   -Wunusable-partial-specialization
#         %select{class|variable}0 template partial specialization contains %select{a template parameter|template parameters}1 that cannot be deduced; this partial specialization will never be used
#   -Wunused-command-line-argument
#         %0: '%1' input unused in cpp mode
#         %0: '%1' input unused%select{ when '%3' is present|}2
#         %0: previously preprocessed input%select{ unused when '%2' is present|}1
#         argument '%0' requires profile-guided optimization information
#         argument unused during compilation: '%0'
#         joined argument expects additional value: '%0'
#         the flag '%0' has been deprecated and will be ignored
#   -Wunused-getter-return-value
#         property access result unused - getters should not be used for side effects
#   -Wunused-value
#         container access result unused - container access should not be used for side effects
#         expression result unused
#         expression result unused; should this cast be to 'void'?
#         ignoring return value of function declared with %0 attribute
#     -Wunevaluated-expression
#           expression with side effects has no effect in an unevaluated context
#       -Wpotentially-evaluated-expression
#             expression with side effects will be evaluated despite being used as an operand to 'typeid'
#     -Wunused-comparison
#           %select{equality|inequality|relational|three-way}0 comparison result unused
#     -Wunused-result
#           ignoring return value of function declared with %0 attribute
#   -Wunused-volatile-lvalue
#         expression result unused; assign into a variable to force a volatile load
#   -Wuser-defined-literals
#         user-defined literal suffixes not starting with '_' are reserved%select{; no literal will invoke this operator|}0
#   -Wuser-defined-warnings
#         %0
#   -Wvarargs
#         passing %select{an object that undergoes default argument promotion|an object of reference type|a parameter declared with the 'register' keyword}0 to 'va_start' has undefined behavior
#         second argument to 'va_arg' is of promotable type %0; this va_arg has undefined behavior because arguments will be promoted to %1
#         second argument to 'va_start' is not the last named parameter
#   -Wvec-elem-size
#         vector operands do not have the same elements sizes (%0 and %1)
#   -Wvexing-parse
#         empty parentheses interpreted as a function declaration
#         parentheses were disambiguated as a function declaration
#         parentheses were disambiguated as redundant parentheses around declaration of variable named %0
#   -Wvisibility
#         declaration of %0 will not be visible outside of this function
#         redefinition of %0 will not be visible outside of this function
#   -Wvoid-ptr-dereference
#         ISO C++ does not allow indirection on operand of type %0
#   -Wwrite-strings
#     -Wwritable-strings
#           ISO C++11 does not allow conversion from string literal to %0
#       -Wdeprecated-writable-strings
#         -Wc++11-compat-deprecated-writable-strings
#               conversion from string literal to %0 is deprecated
-W
#   -Wextra
#         call to function without interrupt attribute could clobber interruptee's VFP registers
#     -Wignored-qualifiers
#           '%0' qualifier on function type %1 has no effect
#           '%0' qualifier on omitted return type %1 has no effect
#           '%0' qualifier on reference type %1 has no effect
#           '%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect
#           ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored
#     -Winitializer-overrides
#           initializer overrides prior initialization of this subobject
#           subobject initialization overrides initialization of other fields within its enclosing subobject
#     -Wmissing-field-initializers
#           missing field %0 initializer
#     -Wmissing-method-return-type
#           method has no return type specified; defaults to 'id'
#     -Wnull-pointer-arithmetic
#           arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#           performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0
#     -Wsemicolon-before-method-body
#           semicolon before method body is ignored
#     -Wsign-compare
#           comparison of integers of different signs: %0 and %1
#     -Wunused-parameter
#           unused parameter %0
-Wabi # DUMMY switch
-Wabstract-vbase-init
#     initializer for virtual base class %0 of abstract class %1 will never be used
-Waggregate-return # DUMMY switch
-Warc-repeated-use-of-weak
#     weak %select{variable|property|implicit property|instance variable}0 %1 is accessed multiple times in this %select{function|method|block|lambda}2 but may be unpredictably set to nil; assign to a strong variable to keep the object alive
#   -Warc-maybe-repeated-use-of-weak
#         weak %select{variable|property|implicit property|instance variable}0 %1 may be accessed multiple times in this %select{function|method|block|lambda}2 and may be unpredictably set to nil; assign to a strong variable to keep the object alive
-Warray-bounds-pointer-arithmetic
#     the pointer decremented by %0 refers before the beginning of the array
#     the pointer incremented by %0 refers past the end of the array (that contains %1 element%s2)
-Wassign-enum
#     integer constant not in range of enumerated type %0
-Watomic-properties
#   -Wcustom-atomic-properties
#         atomic by default property %0 has a user defined %select{getter|setter}1 (property should be marked 'atomic' if this is intended)
#   -Wimplicit-atomic-properties
#         property is assumed atomic by default
#         property is assumed atomic when auto-synthesizing the property
-Wauto-import
#     treating #%select{include|import|include_next|__include_macros}0 as an import of module '%1'
-Wbad-function-cast
#     cast from function call of type %0 to non-matching type %1
-Wbinary-literal
#   -Wc++14-binary-literal
#         binary integer literals are a C++14 extension
#   -Wc++98-c++11-compat-binary-literal
#         binary integer literals are incompatible with C++ standards before C++14
#   -Wgnu-binary-literal
#         binary integer literals are a GNU extension
-Wbind-to-temporary-copy
#     C++98 requires an accessible copy constructor for class %2 when binding a reference to a temporary; was %select{private|protected}0
#     no viable constructor %sub{select_initialized_entity_kind}0 of type %1; C++98 requires a copy constructor when binding a reference to a temporary
#   -Wc++98-compat-bind-to-temporary-copy
#         %sub{select_initialized_entity_kind}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98
-Wc++-compat
#     %select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++
-Wc++0x-compat
#   -Wc++11-compat
#         '%0' is a keyword in C++11
#         'auto' storage class specifier is redundant and incompatible with C++11
#         explicit instantiation cannot be 'inline'
#         explicit instantiation of %0 must occur at global scope
#         explicit instantiation of %0 not in a namespace enclosing %1
#         explicit instantiation of %q0 must occur in namespace %1
#         identifier after literal will be treated as a user-defined literal suffix in C++11
#         integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards
#         integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards
#         use of right-shift operator ('>>') in template argument will require parentheses in C++11
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to %0 is deprecated
#     -Wc++11-compat-reserved-user-defined-literal
#           identifier after literal will be treated as a reserved user-defined literal suffix in C++11
#     -Wc++11-narrowing
#           %select{case value|enumerator value|non-type template argument|array size|constexpr if condition}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1
#           constant expression evaluates to %0 which cannot be narrowed to type %1
#           constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11
#           non-constant-expression cannot be narrowed from type %0 to %1 in initializer list
#           non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11
#           type %0 cannot be narrowed to %1 in initializer list
#           type %0 cannot be narrowed to %1 in initializer list in C++11
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wc++98-c++11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
-Wc++0x-extensions
#   -Wc++11-extensions
#         %select{defaulted|deleted}0 function definitions are a C++11 extension
#         '%0' keyword is a C++11 extension
#         'auto' type specifier is a C++11 extension
#         'template' keyword outside of a template
#         'typename' occurs outside of a template
#         alias declarations are a C++11 extension
#         befriending enumeration type %0 is a C++11 extension
#         commas at the end of enumerator lists are a C++11 extension
#         default template arguments for a function template are a C++11 extension
#         enumeration types with a fixed underlying type are a C++11 extension
#         explicit conversion functions are a C++11 extension
#         extern templates are a C++11 extension
#         generalized initializer lists are a C++11 extension
#         implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is a C++11 extension
#         in-class initialization of non-static data member is a C++11 extension
#         non-class friend type %0 is a C++11 extension
#         non-type template argument referring to %select{function|object}0 %1 with internal linkage is a C++11 extension
#         range-based for loop is a C++11 extension
#         reference qualifiers on functions are a C++11 extension
#         rvalue references are a C++11 extension
#         scoped enumerations are a C++11 extension
#         static data member %0 in union is a C++11 extension
#         unelaborated friend declaration is a C++11 extension; specify '%select{struct|interface|union|class|enum}0' to befriend %1
#         use of enumeration in a nested name specifier is a C++11 extension
#         variadic templates are a C++11 extension
#     -Wc++11-extra-semi
#           extra ';' outside of a function is a C++11 extension
#     -Wc++11-inline-namespace
#           inline namespaces are a C++11 feature
#     -Wc++11-long-long
#           'long long' is a C++11 extension
-Wc++0x-narrowing
#   -Wc++11-narrowing
#         %select{case value|enumerator value|non-type template argument|array size|constexpr if condition}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1
#         constant expression evaluates to %0 which cannot be narrowed to type %1
#         constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11
#         non-constant-expression cannot be narrowed from type %0 to %1 in initializer list
#         non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11
#         type %0 cannot be narrowed to %1 in initializer list
#         type %0 cannot be narrowed to %1 in initializer list in C++11
-Wc++11-compat-pedantic
#   -Wc++11-compat
#         '%0' is a keyword in C++11
#         'auto' storage class specifier is redundant and incompatible with C++11
#         explicit instantiation cannot be 'inline'
#         explicit instantiation of %0 must occur at global scope
#         explicit instantiation of %0 not in a namespace enclosing %1
#         explicit instantiation of %q0 must occur in namespace %1
#         identifier after literal will be treated as a user-defined literal suffix in C++11
#         integer literal is too large to be represented in type 'long' and is subject to undefined behavior under C++98, interpreting as 'unsigned long'; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards
#         integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C++98; this literal will %select{have type 'long long'|be ill-formed}0 in C++11 onwards
#         use of right-shift operator ('>>') in template argument will require parentheses in C++11
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to %0 is deprecated
#     -Wc++11-compat-reserved-user-defined-literal
#           identifier after literal will be treated as a reserved user-defined literal suffix in C++11
#     -Wc++11-narrowing
#           %select{case value|enumerator value|non-type template argument|array size|constexpr if condition}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1
#           constant expression evaluates to %0 which cannot be narrowed to type %1
#           constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11
#           non-constant-expression cannot be narrowed from type %0 to %1 in initializer list
#           non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11
#           type %0 cannot be narrowed to %1 in initializer list
#           type %0 cannot be narrowed to %1 in initializer list in C++11
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wc++98-c++11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#   -Wc++98-c++11-c++14-c++17-compat-pedantic
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#   -Wc++98-c++11-c++14-compat-pedantic
#         attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wc++98-c++11-compat-pedantic
#     -Wc++98-c++11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wc++98-c++11-compat-binary-literal
#           binary integer literals are incompatible with C++ standards before C++14
-Wc++14-compat-pedantic
#   -Wc++14-compat
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wc++98-c++11-c++14-c++17-compat-pedantic
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#   -Wc++98-c++11-c++14-compat-pedantic
#         attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
-Wc++17-compat-pedantic
#   -Wc++17-compat
#     -Wc++17-compat-mangling
#           mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
#   -Wc++98-c++11-c++14-c++17-compat-pedantic
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
-Wc++1y-extensions
#   -Wc++14-extensions
#         'decltype(auto)' type specifier is a C++14 extension
#         initialized lambda captures are a C++14 extension
#         multiple return statements in constexpr function is a C++14 extension
#         type definition in a constexpr %select{function|constructor}0 is a C++14 extension
#         use of the %0 attribute is a C++14 extension
#         use of this statement in a constexpr %select{function|constructor}0 is a C++14 extension
#         variable declaration in a constexpr %select{function|constructor}0 is a C++14 extension
#         variable templates are a C++14 extension
#     -Wc++14-binary-literal
#           binary integer literals are a C++14 extension
-Wc++1z-compat
#   -Wc++17-compat
#     -Wc++17-compat-mangling
#           mangled name of %0 will change in C++17 due to non-throwing exception specification in function signature
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wdeprecated-increment-bool
#           incrementing expression of type bool is deprecated and incompatible with C++17
#     -Wdeprecated-register
#           'register' storage class specifier is deprecated and incompatible with C++17
-Wc++1z-extensions
#   -Wc++17-extensions
#         '%select{if|switch}0' initialization statements are a C++17 extension
#         'begin' and 'end' returning different types (%0 and %1) is a C++17 extension
#         'constexpr' on lambda expressions is a C++17 extension
#         ISO C++ standards before C++17 do not allow new expression for type %0 to use list-initialization
#         attributes on %select{a namespace|an enumerator}0 declaration are a C++17 extension
#         capture of '*this' by copy is a C++17 extension
#         constexpr if is a C++17 extension
#         decomposition declarations are a C++17 extension
#         default scope specifier for attributes is a C++17 extension
#         hexadecimal floating literals are a C++17 feature
#         inline variables are a C++17 extension
#         nested namespace definition is a C++17 extension; define each namespace separately
#         pack expansion of using declaration is a C++17 extension
#         pack fold expression is a C++17 extension
#         static_assert with no message is a C++17 extension
#         template template parameter using 'typename' is a C++17 extension
#         use of multiple declarators in a single using declaration is a C++17 extension
#         use of the %0 attribute is a C++17 extension
-Wc++2a-compat-pedantic
#   -Wc++2a-compat
#         '%0' is a keyword in C++2a
#         '<=>' is a single token in C++2a; add a space to avoid a change in behavior
-Wc++2a-extensions
#     default member initializer for bit-field is a C++2a extension
#     explicit capture of 'this' with a capture default of '=' is a C++2a extension
#     invoking a pointer to a 'const &' member function on an rvalue is a C++2a extension
-Wc++98-compat-pedantic
#     #line number greater than 32767 is incompatible with C++98
#     'long long' is incompatible with C++98
#     C++98 requires newline at end of file
#     cast between pointer-to-function and pointer-to-object is incompatible with C++98
#     commas at the end of enumerator lists are incompatible with C++98
#     empty macro arguments are incompatible with C++98
#     extern templates are incompatible with C++98
#     implicit conversion from array size expression of type %0 to %select{integral|enumeration}1 type %2 is incompatible with C++98
#     variadic macros are incompatible with C++98
#   -Wc++98-c++11-c++14-c++17-compat-pedantic
#         invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#   -Wc++98-c++11-c++14-compat-pedantic
#         attributes on %select{a namespace|an enumerator}0 declaration are incompatible with C++ standards before C++17
#         hexadecimal floating literals are incompatible with C++ standards before C++17
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#   -Wc++98-c++11-compat-pedantic
#     -Wc++98-c++11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wc++98-c++11-compat-binary-literal
#           binary integer literals are incompatible with C++ standards before C++14
#   -Wc++98-compat
#         %select{anonymous struct|union}0 member %1 with a non-trivial %sub{select_special_member_kind}2 is incompatible with C++98
#         %select{defaulted|deleted}0 function definitions are incompatible with C++98
#         '%0' keyword is incompatible with C++98
#         '%0' type specifier is incompatible with C++98
#         '<::' is treated as digraph '<:' (aka '[') followed by ':' in C++98
#         'alignas' is incompatible with C++98
#         'auto' type specifier is incompatible with C++98
#         'constexpr' specifier is incompatible with C++98
#         'decltype' type specifier is incompatible with C++98
#         'nullptr' is incompatible with C++98
#         C++11 attribute syntax is incompatible with C++98
#         alias declarations are incompatible with C++98
#         alignof expressions are incompatible with C++98
#         befriending %1 without '%select{struct|interface|union|class|enum}0' keyword is incompatible with C++98
#         befriending enumeration type %0 is incompatible with C++98
#         consecutive right angle brackets are incompatible with C++98 (use '> >')
#         constructor call from initializer list is incompatible with C++98
#         default template arguments for a function template are incompatible with C++98
#         delegating constructors are incompatible with C++98
#         enumeration type in nested name specifier is incompatible with C++98
#         enumeration types with a fixed underlying type are incompatible with C++98
#         explicit conversion functions are incompatible with C++98
#         friend declaration naming a member of the declaring class is incompatible with C++98
#         generalized initializer lists are incompatible with C++98
#         in-class initialization of non-static data members is incompatible with C++98
#         inheriting constructors are incompatible with C++98
#         initialization of initializer_list object is incompatible with C++98
#         inline namespaces are incompatible with C++98
#         jump from switch statement to this case label is incompatible with C++98
#         jump from this goto statement to its label is incompatible with C++98
#         jump from this indirect goto statement to one of its possible targets is incompatible with C++98
#         lambda expressions are incompatible with C++98
#         literal operators are incompatible with C++98
#         noexcept expressions are incompatible with C++98
#         noexcept specifications are incompatible with C++98
#         non-class friend type %0 is incompatible with C++98
#         non-type template argument referring to %select{function|object}0 %1 with internal linkage is incompatible with C++98
#         passing object of trivial but non-POD type %0 through variadic %select{function|block|method|constructor}1 is incompatible with C++98
#         range-based for loop is incompatible with C++98
#         raw string literals are incompatible with C++98
#         redundant parentheses surrounding address non-type template argument are incompatible with C++98
#         reference initialized from initializer list is incompatible with C++98
#         reference qualifiers on functions are incompatible with C++98
#         rvalue references are incompatible with C++98
#         scalar initialized from empty initializer list is incompatible with C++98
#         scoped enumerations are incompatible with C++98
#         specifying character '%0' with a universal character name is incompatible with C++98
#         static data member %0 in union is incompatible with C++98
#         static_assert declarations are incompatible with C++98
#         substitution failure due to access control is incompatible with C++98
#         trailing return types are incompatible with C++98
#         unicode literals are incompatible with C++98
#         universal character name referring to a control character is incompatible with C++98
#         use of 'template' keyword outside of a template is incompatible with C++98
#         use of 'typename' outside of a template is incompatible with C++98
#         use of non-static data member %0 in an unevaluated context is incompatible with C++98
#         use of null pointer as non-type template argument is incompatible with C++98
#         using this character in an identifier is incompatible with C++98
#         variadic templates are incompatible with C++98
#     -Wc++98-c++11-c++14-c++17-compat
#           '<=>' operator is incompatible with C++ standards before C++2a
#           'char8_t' type specifier is incompatible with C++ standards before C++20
#           default member initializer for bit-field is incompatible with C++ standards before C++2a
#           explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a
#     -Wc++98-c++11-c++14-compat
#           %select{if|switch}0 initialization statements are incompatible with C++ standards before C++17
#           'begin' and 'end' returning different types (%0 and %1) is incompatible with C++ standards before C++17
#           by value capture of '*this' is incompatible with C++ standards before C++17
#           constexpr if is incompatible with C++ standards before C++17
#           constexpr on lambda expressions is incompatible with C++ standards before C++17
#           decomposition declarations are incompatible with C++ standards before C++17
#           default scope specifier for attributes is incompatible with C++ standards before C++17
#           inline variables are incompatible with C++ standards before C++17
#           nested namespace definition is incompatible with C++ standards before C++17
#           non-type template parameters declared with %0 are incompatible with C++ standards before C++17
#           pack expansion using declaration is incompatible with C++ standards before C++17
#           pack fold expression is incompatible with C++ standards before C++17
#           static_assert with no message is incompatible with C++ standards before C++17
#           template template parameter using 'typename' is incompatible with C++ standards before C++17
#           unicode literals are incompatible with C++ standards before C++17
#           use of multiple declarators in a single using declaration is incompatible with C++ standards before C++17
#     -Wc++98-c++11-compat
#           'decltype(auto)' type specifier is incompatible with C++ standards before C++14
#           constexpr function with no return statements is incompatible with C++ standards before C++14
#           digit separators are incompatible with C++ standards before C++14
#           initialized lambda captures are incompatible with C++ standards before C++14
#           multiple return statements in constexpr function is incompatible with C++ standards before C++14
#           type definition in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           use of this statement in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable declaration in a constexpr %select{function|constructor}0 is incompatible with C++ standards before C++14
#           variable templates are incompatible with C++ standards before C++14
#     -Wc++98-compat-local-type-template-args
#           local type %0 as template argument is incompatible with C++98
#     -Wc++98-compat-unnamed-type-template-args
#           unnamed type as template argument is incompatible with C++98
#   -Wc++98-compat-bind-to-temporary-copy
#         %sub{select_initialized_entity_kind}1 of type %2 when binding a reference to a temporary would %select{invoke an inaccessible constructor|find no viable constructor|find ambiguous constructors|invoke a deleted constructor}0 in C++98
#   -Wc++98-compat-extra-semi
#         extra ';' outside of a function is incompatible with C++98
-Wc11-extensions
#     %0 is a C11-specific feature
#     _Noreturn functions are a C11-specific feature
#     _Static_assert is a C11-specific feature
#     anonymous structs are a C11 extension
#     anonymous unions are a C11 extension
#     generic selections are a C11-specific feature
-Wc99-compat
#     %select{using this character in an identifier|starting an identifier with this character}0 is incompatible with C99
#     integer literal is too large to be represented in type 'long', interpreting as 'unsigned long' per C89; this literal will %select{have type 'long long'|be ill-formed}0 in C99 onwards
#     unicode literals are incompatible with C99
-Wc99-extensions
#     %select{qualifier in |static |}0array size %select{||'[*] '}0is a C99 feature
#     ISO C99 requires whitespace after the macro name
#     commas at the end of enumerator lists are a C99-specific feature
#     compound literals are a C99-specific feature
#     designated initializers are a C99 feature
#     empty macro arguments are a C99 feature
#     flexible array members are a C99 feature
#     hexadecimal floating constants are a C99 feature
#     initializer for aggregate is not a compile-time constant
#     variable declaration in for loop is a C99-specific feature
-Wcast-align
#     cast from %0 to %1 increases required alignment from %2 to %3
-Wcast-qual
#     cast from %0 to %1 drops %select{const and volatile qualifiers|const qualifier|volatile qualifier}2
#     cast from %0 to %1 must have all intermediate pointers const qualified to be safe
-Wchar-align # DUMMY switch
-WCL4
#   -Wall
#     -Wmost
#       -Wcast-of-sel-type
#             cast of type %0 to %1 is deprecated; use sel_getName instead
#       -Wchar-subscripts
#             array section %select{lower bound|length}0 is of type 'char'
#             array subscript is of type 'char'
#       -Wcomment
#             '/*' within block comment
#             // comments are not allowed in this language
#             escaped newline between */ characters at block comment end
#             multi-line // comment
#       -Wdelete-non-virtual-dtor
#             %select{delete|destructor}0 called on %1 that is abstract but has non-virtual destructor
#             %select{delete|destructor}0 called on non-final %1 that has virtual functions but non-virtual destructor
#       -Wextern-c-compat
#             %select{|empty }0%select{struct|union}1 has size 0 in C, %select{size 1|non-zero size}2 in C++
#       -Wfor-loop-analysis
#             variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body
#             variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body
#       -Wformat
#             %select{field width|precision}0 used with '%1' conversion specifier, resulting in undefined behavior
#             %select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead
#             '%0' is not a valid object format flag
#             '%select{*|.*}0' specified field %select{width|precision}0 is missing a matching 'int' argument
#             cannot mix positional and non-positional arguments in format string
#             data argument position '%0' exceeds the number of data arguments (%1)
#             field %select{width|precision}0 should have type %1, but argument has type %2
#             flag '%0' is ignored when flag '%1' is present
#             flag '%0' results in undefined behavior with '%1' conversion specifier
#             format specifies type %0 but the argument has %select{type|underlying type}2 %1
#             format string contains '\0' within the string body
#             format string is not null-terminated
#             format string missing
#             format string should not be a wide string
#             incomplete format specifier
#             invalid position specified for %select{field width|field precision}0
#             length modifier '%0' results in undefined behavior or no effect with '%1' conversion specifier
#             missing object format flag
#             more '%%' conversions than data arguments
#             no closing ']' for '%%[' in scanf format string
#             object format flags cannot be used with '%0' conversion specifier
#             position arguments in format strings start counting at 1 (not 0)
#             using '%%P' format specifier without precision
#             using '%0' format specifier annotation outside of os_log()/os_trace()
#             zero field width in scanf format string is unused
#         -Wformat-extra-args
#               data argument not used by format string
#         -Wformat-invalid-specifier
#               invalid conversion specifier '%0'
#         -Wformat-security
#               format string is not a string literal (potentially insecure)
#         -Wformat-y2k # DUMMY switch
#         -Wformat-zero-length
#               format string is empty
#         -Wnonnull
#               null passed to a callee that requires a non-null argument
#               null returned from %select{function|method}0 that requires a non-null return value
#       -Wimplicit
#         -Wimplicit-function-declaration
#               implicit declaration of function %0
#               implicit declaration of function %0 is invalid in %select{C99|OpenCL}1
#               implicitly declaring library function '%0' with type %1
#               use of unknown builtin %0
#         -Wimplicit-int
#               type specifier missing, defaults to 'int'
#       -Winfinite-recursion
#             all paths through this function will call itself
#       -Wmismatched-tags
#             %2 defined as %select{a struct|an interface|a class}0%select{| template}1 here but previously declared as %select{a struct|an interface|a class}3%select{| template}1
#             %select{struct|interface|class}0%select{| template}1 %2 was previously declared as a %select{struct|interface|class}3%select{| template}1
#       -Wmissing-braces
#             suggest braces around initialization of subobject
#       -Wmove
#         -Wpessimizing-move
#               moving a local object in a return statement prevents copy elision
#               moving a temporary object prevents copy elision
#         -Wredundant-move
#               redundant move in return statement
#         -Wreturn-std-move
#               local variable %0 will be copied despite being %select{returned|thrown}1 by name
#         -Wself-move
#               explicitly moving variable of type %0 to itself
#       -Wmultichar
#             multi-character character constant
#       -Wobjc-designated-initializers
#             convenience initializer missing a 'self' call to another initializer
#             convenience initializer should not invoke an initializer on 'super'
#             designated initializer invoked a non-designated initializer
#             designated initializer missing a 'super' call to a designated initializer of the super class
#             designated initializer should only invoke a designated initializer on 'super'
#             method override for the designated initializer of the superclass %objcinstance0 not found
#       -Wobjc-flexible-array
#             field %0 can overwrite instance variable %1 with variable sized type %2 in superclass %3
#             field %0 with variable sized type %1 is not visible to subclasses and can conflict with their instance variables
#       -Wobjc-missing-super-calls
#             method possibly missing a [super %0] call
#       -Woverloaded-virtual
#             %q0 hides overloaded virtual %select{function|functions}1
#       -Wprivate-extern
#             use of __private_extern__ on a declaration may not produce external symbol private to the linkage unit and is deprecated
#       -Wreorder
#             %select{field|base class}0 %1 will be initialized after %select{field|base}2 %3
#       -Wreturn-type
#             %select{void function|void method|constructor|destructor}1 %0 should not return a value
#             control may reach end of coroutine; which is undefined behavior because the promise type %0 does not declare 'return_void()'
#             control may reach end of non-void function
#             control may reach end of non-void lambda
#             control reaches end of coroutine; which is undefined behavior because the promise type %0 does not declare 'return_void()'
#             control reaches end of non-void function
#             control reaches end of non-void lambda
#             non-void %select{function|method}1 %0 should return a value
#         -Wreturn-type-c-linkage
#               %0 has C-linkage specified, but returns incomplete type %1 which could be incompatible with C
#               %0 has C-linkage specified, but returns user-defined type %1 which is incompatible with C
#       -Wself-assign
#             explicitly assigning value of variable of type %0 to itself
#         -Wself-assign-field
#               assigning %select{field|instance variable}0 to itself
#         -Wself-assign-overloaded
#               explicitly assigning value of variable of type %0 to itself
#       -Wself-move
#             explicitly moving variable of type %0 to itself
#       -Wsizeof-array-argument
#             sizeof on array function parameter will return size of %0 instead of %1
#       -Wsizeof-array-decay
#             sizeof on pointer operation will return size of %0 instead of %1
#       -Wstring-plus-int
#             adding %0 to a string does not append to the string
#       -Wtrigraphs
#             ignored trigraph would end block comment
#             trigraph converted to '%0' character
#             trigraph ends block comment
#             trigraph ignored
#       -Wuninitialized
#             base class %0 is uninitialized when used here to access %q1
#             block pointer variable %0 is uninitialized when captured by block
#             field %0 is uninitialized when used here
#             reference %0 is not yet bound to a value when used here
#             reference %0 is not yet bound to a value when used within its own initialization
#             variable %0 is uninitialized when %select{used here|captured by block}1
#             variable %0 is uninitialized when used within its own initialization
#         -Wsometimes-uninitialized
#               variable %0 is %select{used|captured}1 uninitialized whenever %select{'%3' condition is %select{true|false}4|'%3' loop %select{is entered|exits because its condition is false}4|'%3' loop %select{condition is true|exits because its condition is false}4|switch %3 is taken|its declaration is reached|%3 is called}2
#         -Wstatic-self-init
#               static variable %0 is suspiciously used within its own initialization
#       -Wunknown-pragmas
#             #pragma warning expected '%0'
#             #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#             #pragma warning expected a warning number
#             #pragma warning(push, level) requires a level between 0 and 4
#             angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"
#             double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>
#             expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#             expected end of directive in pragma
#             pragma STDC FENV_ACCESS ON is not supported, ignoring pragma
#             pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#             pragma diagnostic expected option name (e.g. "-Wundef")
#             pragma diagnostic pop could not pop, no matching push
#             pragma include_alias expected '%0'
#             pragma include_alias expected include filename
#             unexpected token in pragma diagnostic
#             unknown pragma ignored
#             unknown pragma in STDC namespace
#       -Wunused
#         -Wunused-argument # DUMMY switch
#         -Wunused-function
#               unused function %0
#           -Wunneeded-internal-declaration
#                 %select{function|variable}0 %1 is not needed and will not be emitted
#                 'static' function %0 declared in header file should be declared 'static inline'
#         -Wunused-label
#               unused label %0
#         -Wunused-lambda-capture
#               lambda capture %0 is not %select{used|required to be captured for this use}1
#         -Wunused-local-typedef
#               unused %select{typedef|type alias}0 %1
#         -Wunused-private-field
#               private field %0 is not used
#         -Wunused-property-ivar
#               ivar %0 which backs the property is not referenced in this property's accessor
#         -Wunused-value
#               container access result unused - container access should not be used for side effects
#               expression result unused
#               expression result unused; should this cast be to 'void'?
#               ignoring return value of function declared with %0 attribute
#           -Wunevaluated-expression
#                 expression with side effects has no effect in an unevaluated context
#             -Wpotentially-evaluated-expression
#                   expression with side effects will be evaluated despite being used as an operand to 'typeid'
#           -Wunused-comparison
#                 %select{equality|inequality|relational|three-way}0 comparison result unused
#           -Wunused-result
#                 ignoring return value of function declared with %0 attribute
#         -Wunused-variable
#               unused variable %0
#           -Wunused-const-variable
#                 unused variable %0
#       -Wuser-defined-warnings
#             %0
#       -Wvolatile-register-var # DUMMY switch
#     -Wparentheses
#           %0 has lower precedence than %1; %1 will be evaluated first
#           operator '?:' has lower precedence than '%0'; '%0' will be evaluated first
#           using the result of an assignment as a condition without parentheses
#       -Wbitwise-op-parentheses
#             '%0' within '%1'
#       -Wdangling-else
#             add explicit braces to avoid dangling else
#       -Wlogical-not-parentheses
#             logical not is only applied to the left hand side of this %select{comparison|bitwise operator}0
#       -Wlogical-op-parentheses
#             '&&' within '||'
#       -Woverloaded-shift-op-parentheses
#             overloaded operator %select{>>|<<}0 has higher precedence than comparison operator
#       -Wparentheses-equality
#             equality comparison with extraneous parentheses
#       -Wshift-op-parentheses
#             operator '%0' has lower precedence than '%1'; '%1' will be evaluated first
#     -Wswitch
#           %plural{1:enumeration value %1 not handled in switch|2:enumeration values %1 and %2 not handled in switch|3:enumeration values %1, %2, and %3 not handled in switch|:%0 enumeration values not handled in switch: %1, %2, %3...}0
#           case value not in enumerated type %0
#           overflow converting case value to switch condition type (%0 to %1)
#     -Wswitch-bool
#           switch condition has boolean value
#   -Wextra
#         call to function without interrupt attribute could clobber interruptee's VFP registers
#     -Wignored-qualifiers
#           '%0' qualifier on function type %1 has no effect
#           '%0' qualifier on omitted return type %1 has no effect
#           '%0' qualifier on reference type %1 has no effect
#           '%0' type qualifier%s1 on return type %plural{1:has|:have}1 no effect
#           ARC %select{unused|__unsafe_unretained|__strong|__weak|__autoreleasing}0 lifetime qualifier on return type is ignored
#     -Winitializer-overrides
#           initializer overrides prior initialization of this subobject
#           subobject initialization overrides initialization of other fields within its enclosing subobject
#     -Wmissing-field-initializers
#           missing field %0 initializer
#     -Wmissing-method-return-type
#           method has no return type specified; defaults to 'id'
#     -Wnull-pointer-arithmetic
#           arithmetic on a null pointer treated as a cast from integer to pointer is a GNU extension
#           performing pointer arithmetic on a null pointer has undefined behavior%select{| if the offset is nonzero}0
#     -Wsemicolon-before-method-body
#           semicolon before method body is ignored
#     -Wsign-compare
#           comparison of integers of different signs: %0 and %1
#     -Wunused-parameter
#           unused parameter %0
-Wclass-varargs
#     passing object of class type %0 through variadic %select{function|block|method|constructor}1%select{|; did you mean to call '%3'?}2
#   -Wnon-pod-varargs
#         cannot pass %select{non-POD|non-trivial}0 object of type %1 to variadic %select{function|block|method|constructor}2; expected type from format string was %3
#         cannot pass object of %select{non-POD|non-trivial}0 type %1 through variadic %select{function|block|method|constructor}2; call will abort at runtime
#         second argument to 'va_arg' is of ARC ownership-qualified type %0
#         second argument to 'va_arg' is of non-POD type %0
-Wcomma
#     possible misuse of comma operator here
-Wcomments
#   -Wcomment
#         '/*' within block comment
#         // comments are not allowed in this language
#         escaped newline between */ characters at block comment end
#         multi-line // comment
-Wcomplex-component-init
#     complex initialization specifying real and imaginary components is an extension
-Wconditional-uninitialized
#     variable %0 may be uninitialized when %select{used here|captured by block}1
-Wconsumed
#     argument not in expected state; expected '%0', observed '%1'
#     consumed analysis attribute is attached to member of class '%0' which isn't marked as consumable
#     invalid invocation of method '%0' on a temporary object while it is in the '%1' state
#     invalid invocation of method '%0' on object '%1' while it is in the '%2' state
#     parameter '%0' not in expected state when the function returns: expected '%1', observed '%2'
#     return state set for an unconsumable type '%0'
#     return value not in expected state; expected '%0', observed '%1'
#     state of variable '%0' must match at the entry and exit of loop
-Wcovered-switch-default
#     default label in switch which covers all enumeration values
-Wcstring-format-directive
#     using %0 directive in %select{NSString|CFString}1 which is being passed as a formatting argument to the formatting %select{method|CFfunction}2
-Wctor-dtor-privacy # DUMMY switch
-Wcuda-compat
#     %0 attribute parameter %1 is negative and will be ignored
#     argument to '#pragma unroll' should not be in parentheses in CUDA C/C++
#     ignored 'inline' attribute on kernel function %0
#     kernel function %0 is a member function; this may not be accepted by nvcc
#     nvcc does not allow '__%0__' to appear after '()' in lambdas
-Wdate-time
#     expansion of date or time macro is not reproducible
-Wdeclaration-after-statement
#     ISO C90 forbids mixing declarations and code
-Wdeprecated
#     -O4 is equivalent to -O3
#     OpenCL version %0 does not support the option '%1'
#     Use of 'long' with '__vector' is deprecated
#     access declarations are deprecated; use using declarations instead
#     argument '%0' is deprecated, use '%1' instead
#     definition of implicit copy %select{constructor|assignment operator}1 for %0 is deprecated because it has a user-declared %select{copy %select{assignment operator|constructor}1|destructor}2
#     out-of-line definition of constexpr static data member is redundant in C++17 and is deprecated
#     treating '%0' input as '%1' when in C++ mode, this behavior is deprecated
#   -Wdeprecated-attributes
#         specifying vector types with the 'mode' attribute is deprecated; use the 'vector_size' attribute instead
#   -Wdeprecated-declarations
#         %0 is deprecated
#         %0 is deprecated: %1
#         %0 may be deprecated because the receiver type is unknown
#         property access is using %0 method which is deprecated
#         specifying 'uuid' as an ATL attribute is deprecated; use __declspec instead
#         use of C-style parameters in Objective-C method declarations is deprecated
#   -Wdeprecated-dynamic-exception-spec
#         dynamic exception specifications are deprecated
#   -Wdeprecated-increment-bool
#         incrementing expression of type bool is deprecated and incompatible with C++17
#   -Wdeprecated-register
#         'register' storage class specifier is deprecated and incompatible with C++17
#   -Wdeprecated-this-capture
#         implicit capture of 'this' with a capture default of '=' is deprecated
#   -Wdeprecated-writable-strings
#     -Wc++11-compat-deprecated-writable-strings
#           conversion from string literal to %0 is deprecated
-Wdeprecated-implementations
#     implementing deprecated %select{method|class|category}0
#     implementing unavailable method
-Wdirect-ivar-access
#     instance variable %0 is being directly accessed
-Wdisabled-macro-expansion
#     disabled expansion of recursive macro
-Wdisabled-optimization # DUMMY switch
-Wdiscard-qual # DUMMY switch
-Wdocumentation
#     '%select{\|@}0%1' command does not terminate a verbatim text block
#     '%select{\|@}0%1' command used in a comment that is attached to a %select{function returning void|constructor|destructor|method returning void}2
#     '%select{\|@}0%1' command used in a comment that is not attached to a function or method declaration
#     '%select{\|@}0%select{classdesign|coclass|dependency|helper|helperclass|helps|instancesize|ownership|performance|security|superclass}1' command should not be used in a comment attached to a non-container declaration
#     '%select{\|@}0%select{class|interface|protocol|struct|union}1' command should not be used in a comment attached to a non-%select{class|interface|protocol|struct|union}2 declaration
#     '%select{\|@}0%select{function|functiongroup|method|methodgroup|callback}1' command should be used in a comment attached to %select{a function|a function|an Objective-C method|an Objective-C method|a pointer to function}2 declaration
#     '%select{\|@}0param' command used in a comment that is not attached to a function declaration
#     '%select{\|@}0tparam' command used in a comment that is not attached to a template declaration
#     HTML start tag prematurely ended, expected attribute name or '>'
#     duplicated command '%select{\|@}0%1'
#     empty paragraph passed to '%select{\|@}0%1' command
#     expected quoted string after equals sign
#     not a Doxygen trailing comment
#     parameter '%0' is already documented
#     parameter '%0' not found in the function declaration
#     template parameter '%0' is already documented
#     template parameter '%0' not found in the template declaration
#     unrecognized parameter passing direction, valid directions are '[in]', '[out]' and '[in,out]'
#   -Wdocumentation-deprecated-sync
#         declaration is marked with '\deprecated' command but does not have a deprecation attribute
#   -Wdocumentation-html
#         HTML end tag '%0' is forbidden
#         HTML end tag does not match any start tag
#         HTML start tag '%0' closed by '%1'
#         HTML tag '%0' requires an end tag
-Wdocumentation-pedantic
#     whitespace is not allowed in parameter passing direction
#   -Wdocumentation-unknown-command
#         unknown command tag name
#         unknown command tag name '%0'; did you mean '%1'?
-Wdollar-in-identifier-extension
#     '$' in identifier
-Wdouble-promotion
#     implicit conversion increases floating-point precision: %0 to %1
-Wduplicate-enum
#     element %0 has been implicitly assigned %1 which another element has been assigned
-Wduplicate-method-arg
#     redeclaration of method parameter %0
-Wduplicate-method-match
#     multiple declarations of method %0 found and ignored
-Wdynamic-exception-spec
#     ISO C++17 does not allow dynamic exception specifications
#   -Wdeprecated-dynamic-exception-spec
#         dynamic exception specifications are deprecated
-Weffc++
#   -Wnon-virtual-dtor
#         %0 has virtual functions but non-virtual destructor
-Wembedded-directive
#     embedding a directive within macro arguments has undefined behavior
-Wempty-translation-unit
#     ISO C requires a translation unit to contain at least one declaration
-Wexit-time-destructors
#     declaration requires an exit-time destructor
-Wexpansion-to-defined
#     macro expansion producing 'defined' has undefined behavior
-Wexplicit-ownership-type
#     method parameter of type %0 with no explicit ownership
-Wextra-semi
#     extra ';' %select{outside of a function|inside a %1|inside instance variable list|after member function definition}0
#     extra ';' after member function definition
#   -Wc++11-extra-semi
#         extra ';' outside of a function is a C++11 extension
#   -Wc++98-compat-extra-semi
#         extra ';' outside of a function is incompatible with C++98
-Wflexible-array-extensions
#     %0 may not be nested in a struct due to flexible array member
#     %0 may not be used as an array element due to flexible array member
-Wfloat-equal
#     comparing floating point with == or != is unsafe
-Wformat-non-iso
#     '%0' %select{length modifier|conversion specifier}1 is not supported by ISO C
#     positional arguments are not supported by ISO C
#     using length modifier '%0' with conversion specifier '%1' is not supported by ISO C
-Wformat-pedantic
#     %select{values of type|enum values with underlying type}2 '%0' should not be used as format arguments; add an explicit cast to %1 instead
#     format specifies type %0 but the argument has %select{type|underlying type}2 %1
-Wformat=2
#   -Wformat-nonliteral
#         format string is not a string literal
#   -Wformat-security
#         format string is not a string literal (potentially insecure)
#   -Wformat-y2k # DUMMY switch
-Wfour-char-constants
#     multi-character character constant
-Wfuture-compat # DUMMY switch
-Wgcc-compat
#     '%0' is bound to current loop, GCC binds it to the enclosing loop
#     'break' is bound to loop, GCC binds it to switch
#     'diagnose_if' is a clang extension
#     'enable_if' is a clang extension
#     GCC does not allow %0 attribute in this position on a function definition
#     GCC does not allow an attribute in this position on a function declaration
#     GCC does not allow the %0 attribute to be written on a type
#     GCC does not allow the 'cleanup' attribute argument to be anything other than a simple identifier
#     GCC does not allow variable declarations in for loop initializers before C99
#     __final is a GNU extension, consider using C++11 final
-Wglobal-constructors
#     declaration requires a global constructor
#     declaration requires a global destructor
-Wgnu
#   -Wgnu-alignof-expression
#         %0 applied to an expression is a GNU extension
#   -Wgnu-anonymous-struct
#         anonymous structs are a GNU extension
#   -Wgnu-auto-type
#         '__auto_type' is a GNU extension
#   -Wgnu-binary-literal
#         binary integer literals are a GNU extension
#   -Wgnu-case-range
#         use of GNU case range extension
#   -Wgnu-complex-integer
#         complex integer types are a GNU extension
#   -Wgnu-compound-literal-initializer
#         initialization of an array %diff{of type $ from a compound literal of type $|from a compound literal}0,1 is a GNU extension
#   -Wgnu-conditional-omitted-operand
#         use of GNU ?: conditional expression extension, omitting middle operand
#   -Wgnu-designator
#         use of GNU 'missing =' extension in designator
#         use of GNU array range extension
#         use of GNU old-style field designator extension
#   -Wgnu-empty-initializer
#         use of GNU empty initializer extension
#   -Wgnu-empty-struct
#         %select{struct|union}0 without named members is a GNU extension
#         empty %select{struct|union}0 is a GNU extension
#         flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a GNU extension
#   -Wgnu-flexible-array-initializer
#         flexible array initialization is a GNU extension
#   -Wgnu-flexible-array-union-member
#         flexible array member %0 in a union is a GNU extension
#   -Wgnu-folding-constant
#         expression is not an %select{integer|integral}0 constant expression; folding it to a constant is a GNU extension
#         in-class initializer for static data member is not a constant expression; folding it to a constant is a GNU extension
#         variable length array folded to constant array as an extension
#   -Wgnu-imaginary-constant
#         imaginary constants are a GNU extension
#   -Wgnu-include-next
#         #include_next is a language extension
#   -Wgnu-label-as-value
#         use of GNU address-of-label extension
#         use of GNU indirect-goto extension
#   -Wgnu-redeclared-enum
#         redeclaration of already-defined enum %0 is a GNU extension
#   -Wgnu-statement-expression
#         use of GNU statement expression extension
#   -Wgnu-static-float-init
#         in-class initializer for static data member of type %0 is a GNU extension
#   -Wgnu-string-literal-operator-template
#         string literal operator templates are a GNU extension
#   -Wgnu-union-cast
#         cast to union type is a GNU extension
#   -Wgnu-variable-sized-type-not-at-end
#         field %0 with variable sized type %1 not at the end of a struct or class is a GNU extension
#   -Wgnu-zero-line-directive
#         #line directive with zero argument is a GNU extension
#   -Wgnu-zero-variadic-macro-arguments
#         must specify at least one argument for '...' parameter of variadic macro
#         token pasting of ',' and __VA_ARGS__ is a GNU extension
#   -Wredeclared-class-member
#         class member cannot be redeclared
#   -Wvla-extension
#         variable length arrays are a C99 feature
#   -Wzero-length-array
#         zero size arrays are an extension
-Wheader-hygiene
#     using namespace directive in global context in header
-Widiomatic-parentheses
#     using the result of an assignment as a condition without parentheses
-Wimplicit-fallthrough
#     fallthrough annotation in unreachable code
#     unannotated fall-through between switch labels
#   -Wimplicit-fallthrough-per-function
#         unannotated fall-through between switch labels in partly-annotated function
-Wimplicit-retain-self
#     block implicitly retains 'self'; explicitly mention 'self' to indicate this is intended behavior
-Wimport # DUMMY switch
-Wimport-preprocessor-directive-pedantic
#     #import is a language extension
-Wincomplete-module
#   -Wincomplete-umbrella
#         missing submodule '%0'
#         umbrella directory '%0' not found
#         umbrella header for module '%0' does not include header '%1'
#   -Wnon-modular-include-in-module
#         include of non-modular header inside module '%0': '%1'
#     -Wnon-modular-include-in-framework-module
#           include of non-modular header inside framework module '%0': '%1'
-Winconsistent-missing-destructor-override
#     %0 overrides a destructor but is not marked 'override'
-Winit-self # DUMMY switch
-Winline # DUMMY switch
-Winvalid-or-nonexistent-directory
#     environment variable SCE_ORBIS_SDK_DIR is set, but points to invalid or nonexistent directory '%0'
#     unable to find %0 directory, expected to be in '%1'
-Winvalid-pch # DUMMY switch
-Wkeyword-macro
#     keyword is hidden by macro definition
-Wlanguage-extension-token
#     extension used
-Wliblto # DUMMY switch
-Wlocal-type-template-args
#     template argument uses local type %0
#   -Wc++98-compat-local-type-template-args
#         local type %0 as template argument is incompatible with C++98
-Wlong-long
#     'long long' is an extension when C99 mode is not enabled
#   -Wc++11-long-long
#         'long long' is a C++11 extension
-Wloop-analysis
#   -Wfor-loop-analysis
#         variable %0 is %select{decremented|incremented}1 both in the loop header and in the loop body
#         variable%select{s| %1|s %1 and %2|s %1, %2, and %3|s %1, %2, %3, and %4}0 used in loop condition not modified in loop body
#   -Wrange-loop-analysis
#         loop variable %0 %diff{has type $ but is initialized with type $| is initialized with a value of a different type}1,2 resulting in a copy
#         loop variable %0 is always a copy because the range of type %1 does not return a reference
#         loop variable %0 of type %1 creates a copy from type %2
-Wmain
#     'main' is not allowed to be declared _Noreturn
#     'main' is not allowed to be declared variadic
#     'main' should not be declared static
#     ISO C++ does not allow 'main' to be used by a program
#     bool literal returned from 'main'
#     only one parameter on 'main' declaration
#     variable named 'main' with external linkage has undefined behavior
-Wmethod-signatures
#     conflicting parameter types in implementation of %0: %1 vs %2
#     conflicting return type in implementation of %0: %1 vs %2
-Wmicrosoft
#   -Winconsistent-dllimport
#         %q0 redeclared without %1 attribute: previous %1 ignored
#         %q0 redeclared without 'dllimport' attribute: 'dllexport' attribute added
#   -Wmicrosoft-anon-tag
#         anonymous %select{structs|unions}0 are a Microsoft extension
#         types declared in an anonymous %select{struct|union}0 are a Microsoft extension
#   -Wmicrosoft-cast
#         implicit conversion between pointer-to-function and pointer-to-object is a Microsoft extension
#         static_cast between pointer-to-function and pointer-to-object is a Microsoft extension
#   -Wmicrosoft-charize
#         charizing operator #@ is a Microsoft extension
#   -Wmicrosoft-comment-paste
#         pasting two '/' tokens into a '//' comment is a Microsoft extension
#   -Wmicrosoft-const-init
#         default initialization of an object of const type %0%select{| without a user-provided default constructor}1 is a Microsoft extension
#   -Wmicrosoft-cpp-macro
#         C++ operator %0 (aka %1) used as a macro name
#   -Wmicrosoft-default-arg-redefinition
#         redefinition of default argument
#   -Wmicrosoft-end-of-file
#         treating Ctrl-Z as end-of-file is a Microsoft extension
#   -Wmicrosoft-enum-forward-reference
#         forward references to 'enum' types are a Microsoft extension
#   -Wmicrosoft-enum-value
#         enumerator value is not representable in the underlying type %0
#   -Wmicrosoft-exception-spec
#         %0 is missing exception specification '%1'
#         %select{|pointer to |reference to }0incomplete type %1 is not allowed in exception specification
#         exception specification in declaration does not match previous declaration
#         exception specification in explicit instantiation does not match instantiated one
#         exception specification of '...' is a Microsoft extension
#         exception specification of overriding function is more lax than base version
#   -Wmicrosoft-explicit-constructor-call
#         explicit constructor calls are a Microsoft extension
#   -Wmicrosoft-extra-qualification
#         extra qualification on member %0
#   -Wmicrosoft-fixed-enum
#         enumeration types with a fixed underlying type are a Microsoft extension
#   -Wmicrosoft-flexible-array
#         flexible array member %0 in a union is a Microsoft extension
#         flexible array member %0 in otherwise empty %select{struct|interface|union|class|enum}1 is a Microsoft extension
#   -Wmicrosoft-goto
#         jump from this goto statement to its label is a Microsoft extension
#   -Wmicrosoft-include
#         #include resolved using non-portable Microsoft search rules as: %0
#   -Wmicrosoft-mutable-reference
#         'mutable' on a reference type is a Microsoft extension
#   -Wmicrosoft-pure-definition
#         function definition with pure-specifier is a Microsoft extension
#   -Wmicrosoft-redeclare-static
#         redeclaring non-static %0 as static is a Microsoft extension
#   -Wmicrosoft-sealed
#         'sealed' keyword is a Microsoft extension
#   -Wmicrosoft-template
#         %select{class template|class template partial|variable template|variable template partial|function template|member function|static data member|member class|member enumeration}0 specialization of %1 not in %select{a namespace enclosing %2|class %2 or an enclosing namespace}3 is a Microsoft extension
#         duplicate explicit instantiation of %0 ignored as a Microsoft extension
#         non-type template argument containing a dereference operation is a Microsoft extension
#         template argument for template type parameter must be a type; omitted 'typename' is a Microsoft extension
#         use of identifier %0 found via unqualified lookup into dependent bases of class templates is a Microsoft extension
#         use of undeclared identifier %0; unqualified lookup into dependent bases of class template %1 is a Microsoft extension
#         using the undeclared type %0 as a default template argument is a Microsoft extension
#   -Wmicrosoft-union-member-reference
#         union member %0 has reference type %1, which is a Microsoft extension
#   -Wmicrosoft-unqualified-friend
#         unqualified friend declaration referring to type outside of the nearest enclosing namespace is a Microsoft extension; add a nested name specifier
#   -Wmicrosoft-using-decl
#         using declaration referring to inaccessible member '%0' (which refers to accessible member '%1') is a Microsoft compatibility extension
#   -Wmicrosoft-void-pseudo-dtor
#         pseudo-destructors on type void are a Microsoft extension
-Wmissing-format-attribute # DUMMY switch
-Wmissing-include-dirs # DUMMY switch
-Wmissing-noreturn
#     %select{function|method}0 %1 could be declared with attribute 'noreturn'
#     block could be declared with attribute 'noreturn'
-Wmissing-prototypes
#     no previous prototype for function %0
-Wmissing-variable-declarations
#     no previous extern declaration for non-static variable %0
-Wmodule-build
#     building module '%0' as '%1'
#     could not acquire lock file for module '%0': %1
#     finished building module '%0'
#     timed out waiting to acquire lock file for module '%0'
-Wnarrowing
#   -Wc++11-narrowing
#         %select{case value|enumerator value|non-type template argument|array size|constexpr if condition}0 %select{cannot be narrowed from type %2 to %3|evaluates to %2, which cannot be narrowed to type %3}1
#         constant expression evaluates to %0 which cannot be narrowed to type %1
#         constant expression evaluates to %0 which cannot be narrowed to type %1 in C++11
#         non-constant-expression cannot be narrowed from type %0 to %1 in initializer list
#         non-constant-expression cannot be narrowed from type %0 to %1 in initializer list in C++11
#         type %0 cannot be narrowed to %1 in initializer list
#         type %0 cannot be narrowed to %1 in initializer list in C++11
-Wnested-anon-types
#     anonymous types declared in an anonymous %select{struct|union}0 are an extension
-Wnested-externs # DUMMY switch
-Wnewline-eof
#     no newline at end of file
-Wnon-gcc
#   -Wconversion
#         implicit conversion discards imaginary component: %0 to %1
#         implicit conversion loses floating-point precision: %0 to %1
#         implicit conversion loses integer precision: %0 to %1
#         implicit conversion turns vector to scalar: %0 to %1
#         implicit conversion when assigning computation result loses floating-point precision: %0 to %1
#         non-type template argument value '%0' truncated to '%1' for template parameter of type %2
#         non-type template argument with value '%0' converted to '%1' for unsigned template parameter of type %2
#     -Wbitfield-enum-conversion
#           assigning value of signed enum type %1 to unsigned bit-field %0; negative enumerators of enum %1 will be converted to positive values
#           bit-field %0 is not wide enough to store all enumerators of %1
#           signed bit-field %0 needs an extra bit to represent the largest positive enumerators of %1
#     -Wbool-conversion
#           initialization of pointer of type %0 to null from a constant boolean expression
#       -Wpointer-bool-conversion
#             address of%select{| function| array}0 '%1' will always evaluate to 'true'
#             nonnull %select{function call|parameter}0 '%1' will evaluate to 'true' on first encounter
#       -Wundefined-bool-conversion
#             'this' pointer cannot be null in well-defined C++ code; pointer may be assumed to always convert to true
#             reference cannot be bound to dereferenced null pointer in well-defined C++ code; pointer may be assumed to always convert to true
#     -Wconstant-conversion
#           implicit conversion from %2 to %3 changes value from %0 to %1
#       -Wbitfield-constant-conversion
#             implicit truncation from %2 to bit-field changes value from %0 to %1
#     -Wenum-conversion
#           implicit conversion from enumeration type %0 to different enumeration type %1
#     -Wfloat-conversion
#           implicit conversion turns floating-point number into integer: %0 to %1
#       -Wfloat-overflow-conversion
#             implicit conversion from %0 to %1 changes value from %2 to %3
#             implicit conversion of out of range value from %0 to %1 is undefined
#       -Wfloat-zero-conversion
#             implicit conversion from %0 to %1 changes non-zero value from %2 to %3
#     -Wint-conversion
#           incompatible integer to pointer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#           incompatible pointer to integer conversion %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2%select{|; dereference with *|; take the address with &|; remove *|; remove &}3
#     -Wliteral-conversion
#           implicit conversion from %0 to %1 changes value from %2 to %3
#           implicit conversion of out of range value from %0 to %1 is undefined
#     -Wnon-literal-null-conversion
#           expression which evaluates to zero treated as a null pointer constant of type %0
#     -Wnull-conversion
#           implicit conversion of %select{NULL|nullptr}0 constant to %1
#     -Wobjc-literal-conversion
#           implicit boolean conversion of Objective-C object literal always evaluates to true
#           object of type %0 is not compatible with %select{array element type|dictionary key type|dictionary value type}1 %2
#     -Wshorten-64-to-32
#           implicit conversion loses integer precision: %0 to %1
#     -Wsign-conversion
#           implicit conversion changes signedness: %0 to %1
#           operand of ? changes signedness: %0 to %1
#     -Wstring-conversion
#           implicit conversion turns string literal into bool: %0 to %1
#   -Wliteral-range
#         magnitude of floating-point constant too large for type %0; maximum is %1
#         magnitude of floating-point constant too small for type %0; minimum is %1
#   -Wsign-compare
#         comparison of integers of different signs: %0 and %1
-Wnonportable-cfstrings # DUMMY switch
-Wnonportable-system-include-path
#     non-portable path to file '%0'; specified path differs in case from file name on disk
-Wnullability-extension
#     type nullability specifier %0 is a Clang extension
-Wnullable-to-nonnull-conversion
#     implicit conversion from nullable pointer %0 to non-nullable pointer type %1
-Wobjc-interface-ivars
#     declaration of instance variables in the interface is deprecated
-Wobjc-messaging-id
#     messaging unqualified id
-Wobjc-missing-property-synthesis
#     auto property synthesis is synthesizing property not explicitly synthesized
-Wold-style-cast
#     use of old-style cast
-Wold-style-definition # DUMMY switch
-Wover-aligned
#     type %0 requires %1 bytes of alignment and the default allocator only guarantees %2 bytes
-Woverflow # DUMMY switch
-Woverlength-strings
#     string literal of length %0 exceeds maximum length %1 that %select{C90|ISO C99|C++}2 compilers are required to support
-Woverriding-method-mismatch
#     conflicting distributed object modifiers on parameter type in declaration of %0
#     conflicting distributed object modifiers on return type in declaration of %0
#     conflicting parameter types in declaration of %0%diff{: $ vs $|}1,2
#     conflicting parameter types in declaration of %0: %1 vs %2
#     conflicting return type in declaration of %0%diff{: $ vs $|}1,2
#     conflicting return type in declaration of %0: %1 vs %2
#     conflicting variadic declaration of method and its implementation
-Wpacked
#     packed attribute is unnecessary for %0
-Wpadded
#     padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align %4
#     padding %select{struct|interface|class}0 %1 with %2 %select{byte|bit}3%s2 to align anonymous bit-field
#     padding size of %0 with %1 %select{byte|bit}2%s1 to alignment boundary
-Wpartial-availability
#   -Wunguarded-availability
#         %0 is only available on %1 %2 or newer
#     -Wunguarded-availability-new
#           %0 is only available on %1 %2 or newer
-Wpass
#     %0
-Wpass-analysis
#     %0
#     %0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop or by providing the compiler option '-ffast-math'.
#     %0; allow reordering by specifying '#pragma clang loop vectorize(enable)' before the loop. If the arrays will always be independent specify '#pragma clang loop vectorize(assume_safety)' before the loop or provide the '__restrict__' qualifier with the independent array arguments. Erroneous results will occur if these options are incorrectly applied!
-Wpass-missed
#     %0
-Wpedantic # DUMMY switch
-Wpedantic-core-features
#     OpenCL extension %0 is core feature or supported optional core feature - ignoring
-Wpointer-arith
#     arithmetic on%select{ a|}0 pointer%select{|s}0 to void is a GNU extension
#     arithmetic on%select{ a|}0 pointer%select{|s}0 to%select{ the|}2 function type%select{|s}2 %1%select{| and %3}2 is a GNU extension
#     invalid application of '%select{sizeof|alignof|vec_step}0' to a function type
#     invalid application of '%select{sizeof|alignof|vec_step}0' to a void type
#     subscript of a pointer to void is a GNU extension
#     subtraction of pointers to type %0 of zero size has undefined behavior
-Wpointer-to-int-cast # DUMMY switch
-Wpragmas
#     #pragma redefine_extname is applicable to external C declarations only; not applied to %select{function|variable}0 %1
#   -Wignored-pragmas
#         #pragma %0(pop, ...) failed: %1
#         #pragma options align=reset failed: %0
#         '#pragma comment %0' ignored
#         '#pragma init_seg' is only supported when targeting a Microsoft environment
#         OpenCL extension end directive mismatches begin directive - ignoring
#         expected #pragma pack parameter to be '1', '2', '4', '8', or '16'
#         expected %select{'enable', 'disable', 'begin' or 'end'|'disable'}0 - ignoring
#         expected '#pragma unused' argument to be a variable name
#         expected ')' or ',' in '#pragma %0'
#         expected ',' in '#pragma %0'
#         expected '=' following '#pragma %select{align|options align}0' - ignored
#         expected 'align' following '#pragma options' - ignored
#         expected 'compiler', 'lib', 'user', or a string literal for the section name in '#pragma %0' - ignored
#         expected a stack label or a string literal for the section name in '#pragma %0' - ignored
#         expected a string literal for the section name in '#pragma %0' - ignored
#         expected action or ')' in '#pragma %0' - ignored
#         expected identifier in '#pragma %0' - ignored
#         expected integer between %0 and %1 inclusive in '#pragma %2' - ignored
#         expected integer or identifier in '#pragma pack' - ignored
#         expected non-wide string literal in '#pragma %0'
#         expected push, pop or a string literal for the section name in '#pragma %0' - ignored
#         expected string literal in '#pragma %0' - ignoring
#         extra tokens at end of '#pragma %0' - ignored
#         incorrect use of #pragma clang force_cuda_host_device begin|end
#         incorrect use of '#pragma ms_struct on|off' - ignored
#         invalid alignment option in '#pragma %select{align|options align}0' - ignored
#         known but unsupported action '%1' for '#pragma %0' - ignored
#         missing '(' after '#pragma %0' - ignoring
#         missing ')' after '#pragma %0' - ignoring
#         missing ':' after %0 - ignoring
#         missing ':' or ')' after %0 - ignoring
#         missing argument to '#pragma %0'%select{|; expected %2}1
#         missing argument to debug command '%0'
#         only variables can be arguments to '#pragma unused'
#         pragma pop_macro could not pop '%0', no matching push_macro
#         undeclared variable %0 used as an argument for '#pragma unused'
#         unexpected argument '%0' to '#pragma %1'%select{|; expected %3}2
#         unexpected debug command '%0'
#         unknown OpenCL extension %0 - ignoring
#         unknown action '%1' for '#pragma %0' - ignored
#         unknown action for '#pragma %0' - ignored
#         unsupported OpenCL extension %0 - ignoring
#     -Wignored-pragma-intrinsic
#           %0 is not a recognized builtin%select{|; consider including <intrin.h> to access non-builtin intrinsics}1
#     -Wignored-pragma-optimize
#           '#pragma optimize' is not supported
#   -Wpragma-clang-attribute
#         unused attribute %0 in '#pragma clang attribute push' region
#   -Wpragma-pack
#         the current #pragma pack aligment value is modified in the included file
#         unterminated '#pragma pack (push, ...)' at end of file
#     -Wpragma-pack-suspicious-include
#           non-default #pragma pack value changes the alignment of struct or union members in the included file
#   -Wunknown-pragmas
#         #pragma warning expected '%0'
#         #pragma warning expected 'push', 'pop', 'default', 'disable', 'error', 'once', 'suppress', 1, 2, 3, or 4
#         #pragma warning expected a warning number
#         #pragma warning(push, level) requires a level between 0 and 4
#         angle-bracketed include <%0> cannot be aliased to double-quoted include "%1"
#         double-quoted include "%0" cannot be aliased to angle-bracketed include <%1>
#         expected 'ON' or 'OFF' or 'DEFAULT' in pragma
#         expected end of directive in pragma
#         pragma STDC FENV_ACCESS ON is not supported, ignoring pragma
#         pragma diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'
#         pragma diagnostic expected option name (e.g. "-Wundef")
#         pragma diagnostic pop could not pop, no matching push
#         pragma include_alias expected '%0'
#         pragma include_alias expected include filename
#         unexpected token in pragma diagnostic
#         unknown pragma ignored
#         unknown pragma in STDC namespace
-Wprofile-instr-missing
#     profile data may be incomplete: of %0 function%s0, %1 %plural{1:has|:have}1 no data
-Wquoted-include-in-framework-header
#     double-quoted include "%0" in framework header, expected angle-bracketed instead
-Wreceiver-forward-class
#     receiver %0 is a forward class and corresponding @interface may not exist
#     receiver type %0 for instance message is a forward declaration
-Wredundant-decls # DUMMY switch
-Wredundant-parens
#     redundant parentheses surrounding declarator
-Wremark-backend-plugin
#     %0
-Wreserved-id-macro
#     macro name is a reserved identifier
-Wreserved-user-defined-literal
#     invalid suffix on literal; C++11 requires a space between literal and identifier
#   -Wc++11-compat-reserved-user-defined-literal
#         identifier after literal will be treated as a reserved user-defined literal suffix in C++11
-Wretained-language-linkage
#     friend function %0 retaining previous language linkage is an extension
-Wreturn-std-move-in-c++11
#     prior to the resolution of a defect report against ISO C++11, local variable %0 would have been copied despite being returned by name, due to its not matching the function return type%diff{ ($ vs $)|}1,2
-Wsanitize-address
#     -fsanitize-address-field-padding applied to %0
#     -fsanitize-address-field-padding ignored for %0 because it %select{is not C++|is packed|is a union|is trivially copyable|has trivial destructor|is standard layout|is in a blacklisted file|is blacklisted}1
-Wselector
#     no method with selector %0 is implemented in this translation unit
#   -Wselector-type-mismatch
#         several methods with selector %0 of mismatched types are found for the @selector expression
-Wshadow-all
#   -Wshadow
#         declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2}1
#     -Wshadow-field-in-constructor-modified
#           modifying constructor parameter %0 that shadows a field of %1
#     -Wshadow-ivar
#           local declaration of %0 hides instance variable
#   -Wshadow-field
#         non-static data member %0 of %1 shadows member inherited from type %2
#   -Wshadow-field-in-constructor
#         constructor parameter %0 shadows the field %1 of %2
#     -Wshadow-field-in-constructor-modified
#           modifying constructor parameter %0 that shadows a field of %1
#   -Wshadow-uncaptured-local
#         declaration shadows a %select{local variable|variable in %2|static data member of %2|field of %2|typedef in %2|type alias in %2}1
-Wshift-sign-overflow
#     signed shift result (%0) sets the sign bit of the shift expression's type (%1) and becomes negative
-Wsign-promo # DUMMY switch
-Wsigned-enum-bitfield
#     enums in the Microsoft ABI are signed integers by default; consider giving the enum %0 an unsigned underlying type to make this code portable
-Wsource-uses-openmp
#     OpenMP only allows an ordered construct with the simd clause nested in a simd construct
#     unexpected '#pragma omp ...' in program
-Wspir-compat
#     sampler initializer has invalid %0 bits
-Wstack-protector # DUMMY switch
-Wstatic-in-inline
#     static %select{function|variable}0 %1 is used in an inline function with external linkage
-Wstrict-aliasing # DUMMY switch
-Wstrict-aliasing=0 # DUMMY switch
-Wstrict-aliasing=1 # DUMMY switch
-Wstrict-aliasing=2 # DUMMY switch
-Wstrict-overflow # DUMMY switch
-Wstrict-overflow=0 # DUMMY switch
-Wstrict-overflow=1 # DUMMY switch
-Wstrict-overflow=2 # DUMMY switch
-Wstrict-overflow=3 # DUMMY switch
-Wstrict-overflow=4 # DUMMY switch
-Wstrict-overflow=5 # DUMMY switch
-Wstrict-prototypes
#     this %select{function declaration is not|block declaration is not|old-style function definition is not preceded by}0 a prototype
-Wstrict-selector-match
#     multiple methods named %0 found
-Wsuper-class-method-mismatch
#     method parameter type %diff{$ does not match super class method parameter type $|does not match super class method parameter type}0,1
-Wswitch-default # DUMMY switch
-Wswitch-enum
#     %plural{1:enumeration value %1 not explicitly handled in switch|2:enumeration values %1 and %2 not explicitly handled in switch|3:enumeration values %1, %2, and %3 not explicitly handled in switch|:%0 enumeration values not explicitly handled in switch: %1, %2, %3...}0
-Wsynth # DUMMY switch
-Wtautological-compare
#     %select{self-|array }0comparison always evaluates to %select{a constant|%2}1
#     bitwise comparison always evaluates to %select{false|true}0
#   -Wtautological-constant-compare
#         result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
#     -Wtautological-constant-out-of-range-compare
#           result of comparison of %select{constant %0|true|false}1 with %select{expression of type %2|boolean expression}3 is always %4
#   -Wtautological-overlap-compare
#         overlapping comparisons always evaluate to %select{false|true}0
#   -Wtautological-pointer-compare
#         comparison of %select{address of|function|array}0 '%1' %select{not |}2equal to a null pointer is always %select{true|false}2
#         comparison of nonnull %select{function call|parameter}0 '%1' %select{not |}2equal to a null pointer is '%select{true|false}2' on first encounter
#   -Wtautological-undefined-compare
#         'this' pointer cannot be null in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
#         reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to always evaluate to %select{true|false}0
-Wtautological-constant-in-range-compare
#   -Wtautological-type-limit-compare
#         result of comparison %select{%3|%1}0 %2 %select{%1|%3}0 is always %4
#   -Wtautological-unsigned-enum-zero-compare
#         result of comparison of %select{%3|unsigned enum expression}0 %2 %select{unsigned enum expression|%3}0 is always %4
#   -Wtautological-unsigned-zero-compare
#         result of comparison of %select{%3|unsigned expression}0 %2 %select{unsigned expression|%3}0 is always %4
-Wthread-safety
#   -Wthread-safety-analysis
#         %0 '%1' is acquired exclusively and shared in the same scope
#         %0 '%1' is not held on every path through here
#         %0 '%1' is still held at the end of function
#         %0 '%1' must be acquired before '%2'
#         %select{reading|writing}1 the value pointed to by %0 requires holding %select{any mutex|any mutex exclusively}1
#         %select{reading|writing}1 variable %0 requires holding %select{any mutex|any mutex exclusively}1
#         %select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#         %select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#         Cycle in acquired_before/after dependencies, starting with '%0'
#         acquiring %0 '%1' that is already held
#         calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#         cannot call function '%1' while %0 '%2' is held
#         cannot resolve lock expression
#         expecting %0 '%1' to be held at start of each loop
#         expecting %0 '%1' to be held at the end of function
#         releasing %0 '%1' that was not held
#         releasing %0 '%1' using %select{shared|exclusive}2 access, expected %select{shared|exclusive}3 access
#   -Wthread-safety-attributes
#         %0 attribute can only be applied in a context annotated with 'capability("mutex")' attribute
#         %0 attribute requires arguments whose type is annotated with 'capability' attribute; type here is %1
#         %0 only applies to pointer types; type here is %1
#         ignoring %0 attribute because its argument is invalid
#         invalid capability name '%0'; capability name must be 'mutex' or 'role'
#   -Wthread-safety-precise
#         %select{reading|writing}3 the value pointed to by %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#         %select{reading|writing}3 variable %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#         calling function %1 requires holding %0 %select{'%2'|'%2' exclusively}3
#   -Wthread-safety-reference
#         passing the value that %1 points to by reference requires holding %0 %select{'%2'|'%2' exclusively}3
#         passing variable %1 by reference requires holding %0 %select{'%2'|'%2' exclusively}3
-Wthread-safety-beta
#     Thread safety beta warning.
-Wthread-safety-negative
#     acquiring %0 '%1' requires negative capability '%2'
-Wthread-safety-verbose
#     Thread safety verbose warning.
-Wtype-limits # DUMMY switch
-Wundeclared-selector
#     undeclared selector %0
#     undeclared selector %0; did you mean %1?
-Wundef
#     %0 is not defined, evaluates to 0
-Wundefined-func-template
#     instantiation of function %q0 required here, but no definition is available
-Wundefined-internal-type
#     ISO C++ requires a definition in this translation unit for %select{function|variable}0 %q1 because its type does not have linkage
-Wundefined-reinterpret-cast
#     dereference of type %1 that was reinterpret_cast from type %0 has undefined behavior
#     reinterpret_cast from %0 to %1 has undefined behavior
-Wunnamed-type-template-args
#     template argument uses unnamed type
#   -Wc++98-compat-unnamed-type-template-args
#         unnamed type as template argument is incompatible with C++98
-Wunreachable-code-aggressive
#   -Wunreachable-code
#         code will never be executed
#     -Wunreachable-code-loop-increment
#           loop will run at most once (loop increment never executed)
#   -Wunreachable-code-break
#         'break' will never be executed
#   -Wunreachable-code-return
#         'return' will never be executed
-Wunsupported-dll-base-class-template
#     propagating dll attribute to %select{already instantiated|explicitly specialized}0 base class template without dll attribute is not supported
-Wunused-exception-parameter
#     unused exception parameter %0
-Wunused-local-typedefs
#   -Wunused-local-typedef
#         unused %select{typedef|type alias}0 %1
-Wunused-macros
#     macro is not used
-Wunused-member-function
#     unused member function %0
#   -Wunneeded-member-function
#         member function %0 is not needed and will not be emitted
-Wunused-template
#     unused %select{function|variable}0 template %1
#   -Wunneeded-internal-declaration
#         %select{function|variable}0 %1 is not needed and will not be emitted
#         'static' function %0 declared in header file should be declared 'static inline'
-Wused-but-marked-unused
#     %0 was marked unused but was used
-Wvariadic-macros
#     __VA_OPT__ can only appear in the expansion of a variadic macro
#     named variadic macros are a GNU extension
#     variadic macros are a C99 feature
-Wvector-conversions
#   -Wvector-conversion
#         incompatible vector types %select{%diff{assigning to $ from $|assigning to different types}0,1|%diff{passing $ to parameter of type $|passing to parameter of different type}0,1|%diff{returning $ from a function with result type $|returning from function with different return type}0,1|%diff{converting $ to type $|converting between types}0,1|%diff{initializing $ with an expression of type $|initializing with expression of different type}0,1|%diff{sending $ to parameter of type $|sending to parameter of different type}0,1|%diff{casting $ to type $|casting between types}0,1}2
-Wvla
#     variable length array used
-Wweak-template-vtables
#     explicit template instantiation %0 will emit a vtable in every translation unit
-Wweak-vtables
#     %0 has no out-of-line virtual method definitions; its vtable will be emitted in every translation unit
-Wzero-as-null-pointer-constant
#     zero as null pointer constant
